from contextlib import contextmanager
import nbtlib
import json

from ./utils import Rebindable
from ./config import Config


class DataStash(Rebindable):
    _MARKER_PLAYER_TAG = f"{Config.TAG_ROOT}.datastash.stash.player"
    _MARKER_MOB_TAG = f"{Config.TAG_ROOT}.datastash.stash.mob"
    _REGISTERED_TAG = f"{Config.TAG_ROOT}.datastash.registered"
    _GLOBAL_PATH = f"{Config.ROOT}/datastash"
    _cache_index = -1
    _initialized = False

    def __init__(self, nbt_path: str):
        self.nbt_path = nbtlib.Path(nbt_path)

        if not DataStash._initialized:
            DataStash._initialized = True
            self._init_scoreboard()
            self._garbage_collector()
            self._generate_unregister_mcfunc()
            # self._portal_fix()

    def __str__(self):
        return f"DataStash {self.nbt_path}"

    def get(self, index=None):
        temp_data = self._Data.storage(Config.STORAGE_ROOT).datastash.temp
        with self._use_stash_selector():
            if index is None:
                temp_data = self._this[self.nbt_path]
            else:
                temp_data = self._this[self.nbt_path][index]
        return temp_data

    def set(self, value, index=None):
        with self._use_stash_selector():
            if index is None:
                self._this[self.nbt_path] = value
            else:
                self._this[self.nbt_path][index] = value

    def merge(self, value):
        with self._use_stash_selector():
            self._this[self.nbt_path].merge(value)
    
    def append(self, value):
        with self._use_stash_selector():
            self._this[self.nbt_path].append(value)
    
    def prepend(self, value):
        with self._use_stash_selector():
            self._this[self.nbt_path].prepend(value)
    
    def insert(self, index, value):
        with self._use_stash_selector():
            self._this[self.nbt_path].insert(index, value)
    
    def remove(self, index=None):
        with self._use_stash_selector():
            if index is None:
                self._this[self.nbt_path].remove()
            else:
                self._this[self.nbt_path][index].remove()

    @contextmanager
    def _use_stash_selector(self):
        cache_path = f"{Config.ROOT_LOCAL}/datastash/cache/{self._get_next_cache_index()}"

        self._check_register_status()

        function f"{cache_path}_payload":
            yield True

        if entity @s[type=marker]:
            function cache_path
        unless entity @s[type=marker]:
            execute function f"{cache_path}_cond_0":
                if entity @s[type=player]:
                    execute function f"{cache_path}_pmarker_find":
                        self._datastash_scb['#temp'] = self._datastash_scb['@s']
                        as @e[type=marker, tag=self._MARKER_PLAYER_TAG]:
                            if self._datastash_scb['#temp'] == self._datastash_scb['@s']:
                                function cache_path
                if entity @s[type=!player]:
                    on passengers if entity @s[type=marker,tag=self._MARKER_MOB_TAG]:
                        function cache_path

    @classmethod
    def _get_next_cache_index(cls):
        cls._cache_index += 1
        return cls._cache_index

    @classmethod
    def _check_register_status(cls):
        if entity @s[type=!marker, tag=!cls._REGISTERED_TAG]:         # "@s markers" use their builtin data nbt, can skip registration
            execute function f"{cls._GLOBAL_PATH}/register":
                if entity @s[type=player]:
                    cls._register_player()
                if entity @s[type=!player]:
                    cls._register_mob()
                tag @s add cls._REGISTERED_TAG

    @classmethod
    def _register_player(cls):
        init_tag = 'wicked_expressions.datastash.temp_marker_init'
        custom_name = json.dumps({"text": cls._MARKER_PLAYER_TAG, "color": "green"})
        execute function f"{cls._GLOBAL_PATH}/register_player":
            forceload add 0 0
            summon marker 0 0 0 {Tags: [cls._MARKER_PLAYER_TAG, init_tag], CustomName: custom_name}
            as @e[type=marker, tag=init_tag] run execute function f"{cls._GLOBAL_PATH}/register_player1":
                cls._datastash_scb['@s'] = cls._datastash_scb['#index']
                tag @s remove init_tag
            cls._datastash_scb['@s'] = cls._datastash_scb['#index']
            cls._datastash_scb['#index'] += 1 

    @classmethod
    def _register_mob(cls):
        init_tag = 'wicked_expressions.datastash.temp_init'
        custom_name = json.dumps({"text": cls._MARKER_MOB_TAG, "color": "green"})
        execute function f"{cls._GLOBAL_PATH}/register_mob":
            at @s run summon marker ~ ~ ~ {Tags: [cls._MARKER_MOB_TAG, init_tag], CustomName: custom_name}
            ride @e[type=marker, tag=init_tag, limit=1] mount @s                             # mounts the marker onto the entity            
            tag @e[type=marker, tag=init_tag] remove init_tag

    @classmethod
    def _garbage_collector(cls):
        mcfunc_path = f"{cls._GLOBAL_PATH}/garbage_collector"
        merge function_tag minecraft:load {"values": [mcfunc_path]}
        function mcfunc_path:
            schedule function mcfunc_path 100t replace

            # mob-stash gc
            as @e[type=marker, tag=cls._MARKER_MOB_TAG]:
                execute function f"{mcfunc_path}1":
                    cls._datastash_scb['#temp'] = 0
                    on vehicle:
                        cls._datastash_scb['#temp'] = 1

                    if not cls._datastash_scb['#temp']:
                        kill @s

    @classmethod
    def _generate_unregister_mcfunc(cls):
        execute function f"{cls._GLOBAL_PATH}/unregister":
            if entity @s[type=!marker, tag=cls._REGISTERED_TAG]:
                execute function f"{cls._GLOBAL_PATH}/unregister1":
                    tag @s remove cls._REGISTERED_TAG
                    if entity @s[type=player]:
                        execute function f"{cls._GLOBAL_PATH}/unregister2":
                            cls._datastash_scb['#temp'] = cls._datastash_scb['@s']
                            as @e[type=marker, tag=cls._MARKER_PLAYER_TAG]:
                                if cls._datastash_scb['#temp'] == cls._datastash_scb['@s']:
                                    kill @s
                            cls._datastash_scb['@s'].reset()
                    if entity @s[type=!player]:
                        on passengers if entity @s[type=marker,tag=cls._MARKER_MOB_TAG]:
                            kill @s

    # TODO: fix portals someday

    # @classmethod
    # def _portal_fix(cls):
    #     mcfunc_path = f"{cls._GLOBAL_PATH}/portal_fix"
    #     in_portal_tag = 'wicked_expressions.datastash.portal_fix.in_portal'
    #     portal_guide_tag = 'wicked_expressions.datastash.portal_fix.guide'
    #     temp_tag = 'wicked_expressions.datastash.portal_fix.temp'

    #     merge function_tag minecraft:tick {"values": [mcfunc_path]}
    #     function mcfunc_path:
    #         # debug
    #         as @e[type=marker, tag=cls._MARKER_MOB_TAG] at @s particle flame ~ ~2 ~ 0 0 0 0 1 force
    #         as @e[type=armor_stand, tag=portal_guide_tag] at @s particle soul_fire_flame ~ ~1 ~ 0 0 0 0 1 force

    #         as @e[type=marker, tag=cls._MARKER_MOB_TAG] on vehicle:
    #             if entity @s[tag=!in_portal_tag] at @s if block ~ ~ ~ nether_portal:
    #                 say used magico teleportero
    #                 tag @s add in_portal_tag
    #                 tag @s add temp_tag
    #                 summon armor_stand ~ ~ ~ {Invisible:1b,Tags:[portal_guide_tag]}

    #         as @e[type=armor_stand, tag=portal_guide_tag]:
    #             tp @e[tag=temp_tag] @s
    #             tag @e[tag=temp_tag] remove temp_tag

    #                 # tp @s @e[type=armor_stand,tag=portal_guide_tag,limit=1]
    #                 # kill @e[type=armor_stand,tag=portal_guide_tag]       

    @classmethod
    def monkeypatch(cls, Scoreboard, Data):
        cls._this = Data.entity('@s')
        cls._Scoreboard = Scoreboard
        cls._Data = Data

    @classmethod
    def _init_scoreboard(cls):
        cls._datastash_scb = cls._Scoreboard(f"{Config.SCOREBOARD_ROOT}.datastash")
