#!/usr/bin/python3
# -*- coding: utf-8 -*-

'''Extract information from SAXS/WAXS xlsx log files for data treatment.

(i) Usage:
   XS_extractlog.py [-hstrv] [-i <index>] [-f <file>] 

where:

  -h : this help message.

  -v : verbose, output will include general descriptions. Default is
   quiet.

  -s : divides the into minor files, accordingly to each sample
   (buffers/backgrounds are replicated all along).

  -t : divides the output into minor files, accordingly to each
   measurement temperature.

  -r : rename files accordingly to spreadsheet description in
   saxs_parameters.

  -f <file> : gets data from <file> (extension xlsx). With no
   arguments, gets data from a file named saxs_log.xlsx in current
   directory.

  -i <index> : gets data from sheet number <index>. First sheet is 0,
    which is the default. Only one sheet can be read at a time. To run
    over other sheets, run again with -i 1, -i 2 etc.


(ii) General description. 

XS_extractlog.py extracts data from a SAXS/WAXS
xlsx (spreadsheet) log file and puts results out to a file or files
named saxs_parameters as a set of parameters for further azimuthal (by
XS_azimuthalaverage.py) or radial (by XS_radialaverage.py) integration
. Data is extracted from a spreadsheet tab at a time, and all
information creates a structure under a directory named
Treatment_<n>_<tab_name>, where <n> is the tab sheet number. Each
sample identified in the log file will generate a subdirectory under
Treatment_<n>_<tab_name>, whose name is the sample name. If option -t
is given instead of -s, subdirectories correspond to different
temperatures.

(iii) Log file structure. 

To create names consistently, some key words must be written in the
description (first) cell of the log file, so as to identify the
function of files.

The following keyword rules apply for recognition of parameters
described in the first column of the worksheet, starting from line 38:

  - Buffer/background: contains the word "buffer"
  - Shadow: contains the word "shadow" or "glassy"
  - P.O.N.I. (Point of Normal Incidence): words "behenate", 
     "corundum" or "lab6" 
  - Empty capillary: contains the word "empty"
  - Noise/dark: contains the word "noise" 
  - Water (for absolute scale normalization): contains the word
    "water"
    
Words different from keywords above will be considered as samples. If
your buffer is water, you can use "buffer: H2O" for instance, so
"water" will be considered for absolute scale normalization.

Since each tab of the log file has a header describing the
generalities of the measurement process (users, SAXS / WAXS, vacuum or
air, type of holders, wavelength of the X-ray, etc.), the program
considers the first 37 lines of the tab as a header, hence all
information on samples, backgrounds, beam center, shadow file,
calibrants (silver behenate, corundum, etc.) must be registered from
the 38th line on. Besides that, information about the type of the
experiment, if SAXS or WAXS, _must_be_ in cell (8, 2).

This script tries to guess which buffer/background, water and empty
files correspond to a given sample, by comparing the string formed
before a \':\' in those entries with the correspondent string in the
sample file entry. For instance, an entry with \'cap 005: buffer XY\'
will match an entry with \'cap 005: abcde\'.

Obs. 1: The files generated by this script do not necessarily include
all possibilities for the data treatment. Take due care and check for
the consistency of the parameters shown.


(iv) Typical use of the program.

 $ XS_extractlog.py -sr -i 0 -f saxs_log.xlsx

to extract data from the first (0) tab of saxs_log.xlsx log file,
create directory Treatment_00_<name>, divide sample treatment into
subdirectories with renamed (r) links pointing to original EDF files.

Obs. 2: Currently options -s and -t are not accepted simultaneously.


(v) Example of lines in a log file tab.

silver behenate            2              300       22.0
c05: empty                 9              900       20.0
c05: water                10              900       20.0
c05: buffer H2O           15, 16         1800       37.0
c05: ABC-JK-9             31, 33, 35     1800       37.0
 
Here, the first column indicates the type of measured sample. The c05
prefix identifies the capillary 05 in this case, which will be used to
match the respective measurements of buffer, water, and emptiness in
the same capillary. The second column stands for the EDF file
numbers. The third column is exposure time and the fourth column is
the measurement temperature; those columns are mandatory (an entry is
ignored if either is blank).


(vi) Special parameters.

Normalization, for a a value or method of normalization. Insert the
word \'normalization\' in any first column cell (after line 37) of the
spreadsheet and its respective value in the second cell of the same
line. Otherwise, change manually the value of the parameter "NORM" in
the resulting saxs_parameters file. Possible values are: None, WATER,
GC (glassy carbon), PARFILE or a real number (p.ex.: 0.95). The
default value is NORM = 1.0.

ANGLES, for azimuthal angular interval. If it is necessary to
integrate over \'cuts\' in azimuthal angle, you have to add the ANGLES
parameter to the respective saxs_parameters files.  Type the
integration ranges using the structure: (central angle, delta).  For
example, \'ANGLES = (0, 20) (-45, 10)\' will integrate in both angular
ranges, [-10, 10] and [-50, -40].

QRADII, for integration in Q. For radial integration, the Q range must
be provided. The result is average intensity as a function of the
azimuthal angle. The parameter name is QRADII and it must be given in
a pairwise form, namely, as a tuple. For instance, QRADII = (0.04,
0.12).

This script is part of the XS-treatment suite for SAXS/WAXS data
treatment.

'''

__version__   = '2.4.1'
__author__ = 'Dennys Reis & Arnaldo G. Oliveira-Filho'
__credits__ = 'Dennys Reis & Arnaldo G. Oliveira-Filho'
__email__ = 'dreis@if.usp.br, agolivei@if.usp.br'
__license__ = 'GPL'
__date__   = '2022-09-14'
__status__   = 'Development'
__copyright__ = 'Copyright 2022 by GFCx-IF-USP'
__local__ = 'GFCx-IF-USP'


import errno
import getopt
import glob
import os
import re
import shutil
import sys
import xlrd

#global saxspath
#saxspath = '/usr/local/lib/XS-treatment/'
#sys.path.append(saxspath)

import platform
import imp

global saxspath

try: saxspath = imp.find_module("XS-treatment")
except NameError: print ("Error: The module XS-treatment was not installed.");

if platform.system()== "win32" or platform.system()== "Windows" :
    saxspath =saxspath[1]+'\\'
else :
    saxspath =saxspath[1]+'/'

sys.path.append(saxspath)

import XS_libfileutils as LFU

# Special entries and their respective variable names.
#    'sample'  : 'SAMPLE',
calib_param = {
    'glassy'        : 'SHADOW',
    'shadow'        : 'SHADOW',
    'noise'         : 'NOISE', 
    'behenate'      : 'PONI',
    'corundum'      : 'PONI',
    'lab6'          : 'PONI',
    'direct'        : 'DIRECT',
    'normalization' : 'NORM',
    'subtraction'   : 'MULTISUBT'
}

sample_auxiliary = {
    'buffer'        : 'BACKGROUND',
    'water'         : 'WATER',
    'empty'         : 'EMPTY',
}

# Dictionary of descriptions of parameters: detailed or none.
verbose_description = {
    'SAMPLE'     : '# sample file(s) list, separated by commas',
    'BACKGROUND' : '# buffer files list, files separated by commas',
    'EMPTY'      : '# Normalization factor: empty capillary',
    'MANORM'     : '# Manual normalization factor',
    'XS'         : 'flag: measurements from SAXS or WAXS',
    'PONI'       : ('# PONI (Point Of Normal Incidence) file.'
                     ' Must be generated beforehand'),
    'MASK'       : '# Mask file (p.ex., mask.txt)',
    'SHADOW'     : '# Shadow file (glassy carbon, p.ex.)',
    'NOISE'      : '# Noise file.',
    'DIRECT'     : '# Direct beam file',
    'NORM'       : ('# Normalization factor:\n'
                    '# None, WATER, GC (glassy carbon), PARFILE or a real number.'),
    'PARFILE'    : '# Normalization with PAR file (p.ex., deionized_water.PAR).',
    'WATER'      : ('# Normalization factor: WATER.\n'
                    '# WARNING! this is NOT the reference to the buffer/background!\n'
                    '# If your buffer is water, you have to set the variable\n'
                    '# BACKGROUND with the file names of the buffers as well '),
    'GC'         : '# Normalization factor: glassy carbon',
    'ANGLES'     : ('# ordered pairs for angles: (central angle, sector angular size);' 
                    '\n# angles from 0 to 360, counterclockwise'
                    '\n# ex.: (90,  20) to integrate from  80 to 100 degrees'
                    '\n#      (315, 10) to integrate from 310 to 320 degrees'),
    'QRADII'     : ('# initial and final values of q for integration'),
    'DIRECT'     : '# Direct beam file',
    'MULTISUBT'  : ('# Multiple background subtraction method.' 
                    '\n# True  : all backgrounds subtracted from each sample;'
                    '\n# False : one-to-one association.')
}
#
simple_description =  { k : '' for k in verbose_description }

# Define header for files.
sw_header = lambda swcase : str(5 * '#' + '\n' + 5 * '#' 
                                f' Parameters for {swcase} integration.'
                                '\n# Comment/uncomment entries with a hash (#)'
                                ' if necessary.\n ')

##
def cmd_opt ():
    '''Command line options.  
    h : help message
    v : verbose, output will include general descriptions. Default is quiet.
    f : gets xlsx input file.
    i : gets sheet index (first sheet = 0)
    e : directory names in extended version (include temperature and exposure time).
    r : links with new names to edf files are created.
    s : output is divided into files respectively to samples.
    t : output is divided into files respectively to temperatures.

    '''

    # Read options, if available.
    try:
        opts = getopt.getopt(sys.argv[1:], "hrstvf:i:")
    except getopt.GetoptError as err:
        print ('\n\n ERROR: ', str(err),'\b.')
        sys.exit(1)

    # Dictionary for flags.
    swflag = {}
    swflag['division'] = ''
    swflag['index'] = 0 
    swflag['extname'] = False 
    swflag['renamed'] = False
    swflag['verbose'] = False
    xlsxname = "saxs_log.xlsx"

    for o in opts[0]: 
        if (o[0] == '-h'):
            '''Help message.'''
            help('XS_extractlog')
            sys.exit(0)
            
        elif (o[0] == '-v'):
            swflag['verbose'] = True
        elif (o[0] == '-r'):
            swflag['renamed'] = True
        elif (o[0] == '-e'):
            swflag['extname'] = True
        elif (o[0] == '-f'):
            xlsxname = o[1]
        elif (o[0] == '-i'):
            swflag['index'] = int(o[1])
        elif (o[0] == '-s' or o[0] == '-t'):
            if (swflag['division'] == ''):
                swflag['division'] = 'Samp' if (o[0] == '-s') else 'Temp'
            else:
                print (' ERROR: both sample and temperature options detected.'
                        + ' Please, choose just one.')
                sys.exit(1)
        else:
            print (' WARNING: option {} not recognized. Aborting.'.format(o[0]))

    # Check consistency of division system.
    if (swflag['division'] == ''):
        print(' ERROR: option \'-s\' or \'-t\' not set.')
        sys.exit(1)
            
    # Define default normalization and subtraction methods.
    swflag['normalization'] = '1.0'
    swflag['multisubt'] = True
    
    return xlsxname, swflag

##
def output_messages (xlsxname, wb, swflag):
    '''Generic messages confirming command line arguments.'''
    
    sep = 5 * '#'
    msg = (f'\n{sep}\n{sep}  This program extracts SAXS/WAXS'
           f' parameters from an xlsx spreadsheet.\n{sep}\n'
           f'\n Extracting data from file {xlsxname},'
           ' spreadsheet {} (named {}).'.format(swflag['index'],
                                                 wb.sheet_names()[swflag['index']]))

    
    if (swflag['verbose']):
        msg += '\n Verbose description will be shown.'
    #
    if (swflag['renamed']):
        msg += '\n Links with new names will be created.'
    #
    s_or_t = 'temperature' if (swflag['division'] == 'Temp') else 'sample'
    msg += f'\n Output will be divided in subdirectories per {s_or_t}.'

    print (msg)
    return

##
def _files_list (basename, filenum, sw='_0_', ext='.edf'):
    '''Rebuilds file names from a basename, the set of files numbers, an identifier
    (sw: SAXS/WAXS) and an extension (as 'edf'). Returns a list of the
    resulting file names.

    '''

    # Get files numbers or names.
    if (filenum == ''):
        # If no value is defined, return an empty string.
        return ['']
    elif (isinstance(filenum, (float, int))):
        # If filenum is a float, truncate to integer and cast to string.
        preline = [ str(int(filenum)) ]
    else:
        # If there are multiple values, create a list.
        preline = str(filenum).split(',')

    # Build the list of files.
    line = []
    for item in preline:
        try:
            # If item is a number, rebuild standard name.
            m = int(item.strip())
            n = '{0:0>5}'.format(m)
            name = basename + sw + n + ext
        except:
            # If item is anything else, just append an extension.
            name = item + ext
        line.append(name)
    #
    return line

##
def get_data_from_worksheet (ws, swflag):
    '''Extracts data from worksheet cells.
       ws      : the worksheet object
       swflag  : flags for parameter options
    '''

    # Get current directory basename.
    dirname = os.path.split(os.getcwd())[1]
    
    # Store worksheet data onto SAXS / WAXS dictionaries. Each entry key is the
    # name of the sample (first column) and its value is a dictionary with all
    # related information (from the other columns).
    dataS, dataW = {}, {}

    # Scan spreadsheet from line 37 onwards.
    for nline in range(37, ws.nrows):

        # Store line data in a dictionary.
        cells = {}
        cells['NAME'] = ws.cell(nline, 0).value
        cells['TIME'] = ws.cell(nline, 2).value
        cells['TEMP'] = ws.cell(nline, 3).value
        cells['OBSV'] = ws.cell(nline, 4).value
        files = ws.cell(nline, 1).value
        
        # Sample name is based on first column description plus
        # temperature plus time exposition.
        sname = str(cells['NAME'])
        stime = str(cells['TIME'])
        stemp = str(cells['TEMP'])
        if (swflag['extname']):
            sample = f'{sname}_{stime}s_{stemp}oC'
        else:
            sample = re.sub('[\ ,]+', '_', sname)
        
        # If data is not defined, skip it. 
        if (sname == ''): continue

        # Build data storage for saxs and/or waxs.
        # Build the file list after recreating file names.
        if (swflag['saxs']):
            if (re.search('normalization|subtraction', sname, re.I)):
                cells['FILE'] = files
            else:
                cells['FILE'] = _files_list(dirname, files, '_0_')
            if (cells['FILE'] != ['']):
                dataS[sample] = cells.copy()

        if (swflag['waxs']):
            cells['FILE'] = _files_list(dirname, files, '_1_')
            if (cells['FILE'] != ['']):
                dataW[sample] = cells.copy()

    return (dataS, dataW)

##
def _item_type(sname):
    '''Check whether sname has some pattern related to generic items
    (calibrants, water, empty or buffer).

    '''

    # Check for calibrants.
    for k in calib_param:
        if (re.search(k, sname, re.I)):
            if (k == 'normalization'): return 'Norm'  # Normalization.
            if (k == 'subtraction'): return 'Mult'    # Multi-subtraction.
            return 'Cal'                              # Any calibrant.

    # Check for empty, water or buffer.
    for k in sample_auxiliary:
        if (re.search(k, sname, re.I)): return 'Aux'  # Auxiliary.

    # Sample.
    return 'Samp'

##
def indexes (data, swflag):
    '''Extract information from data by groups: 
    - samples; 
    - empty, water and buffer;
    - calibrants and parameters.

    IndDiv - an index for the parameter sets division (sample or temperature);
             it is specially necessary for temperature grouping.
    IndAux - index for empty, water and buffer data.
    IndCal - index for calibrants and some other paremeters.

    '''

    # Index dictionaries to organize data if parameters must be devided into
    # multiple files (by temperature or by sample), for calibrants and others
    # (water, buffer, empty).
    IndDiv, IndCal, IndAux, AuxObs = {}, {}, {}, {}
    
    # Select grouping mode: by sample or by temperature. In case of
    # division by sample, IndDiv is a kind of indentity operator.
    for DT in data:
        dindex = DT if (swflag['division'] == 'Samp') else data[DT]['TEMP']
        itype = _item_type(data[DT]['NAME'])

        # Set a pointer to due indexer.
        if (itype in ['Norm', 'Mult', 'Cal']):
            TheIndex = IndCal  # Calib. / norm. / mult. / parameters.
        elif (itype == 'Aux'):
            TheIndex = IndAux  # Water, empty, buffer.
            AuxObs[dindex] = data[DT]['OBSV']
        else:
            TheIndex = IndDiv  # Sample.

        # Set flags.
        if (itype == 'Norm'):
            swflag['normalization'] = str(data[DT]['FILE']).upper()
        elif (itype == 'Mult'):
            swflag['multisubt'] = False if (str(data[DT]['FILE']) == 'F') else True

        # Add data to respective indexer dictionary.
        if (((data[DT]['TIME'] != '') and (data[DT]['TEMP'] != '')) or (itype == 'Norm')):
            try:
                TheIndex[dindex] += data[DT]['FILE']
            except:
                TheIndex[dindex] = data[DT]['FILE']

    # Add observations as last item in list of auxiliary index.
    for dindex in IndAux:
        IndAux[dindex].append(str(AuxObs[dindex]))
            
    return (IndDiv, IndAux, IndCal)

##
def _output_template (files, description, swflag, swcase, newbasename,
                      pname, extra_info):
    '''Create output template with filenames for dataset from a given list
    of files (files). The template depends on a description of the
    items, the set of parameters (swflag), the case (swcase:
    SAXS/WAXS), the basename for the samples (newbasename), the
    parameter name (pname: SAMPLE, BACKGROUND, WATER, etc.)  and
    aditional information (extra_info). It returns a tuple (outdata,
    LinkData) with the data string and list of pair of files [orig
    name, new name] of files to be linked in subdirectories
    accordingly.

    '''

    # Initialize output data.
    outdata = (description[pname] + '\n' + extra_info + pname + ' = ')
    nf = len(files)
    if (nf > 1): outdata += ' \ \n'
    LinkData = []
    
    # Add value of item to output data.
    for i in range(nf):
        f = files[i].strip()
        newf = f      # Keep old file name if flag 'renamed' is not set.
        srcdir = ''
        if (swflag['renamed']):
            fext = os.path.splitext(f)[1]
            # Insert the original file number in RDS file name.
            try:
                m = re.findall('_[0-9]{3,5}', f)[0]
            except:
                m = ''
            newf = '{}_{}_{}_{}{}'.format(swcase.upper(), pname.lower(),
                                          newbasename, m, fext)
            newf = newf.replace('_.edf', '.edf')
        #    
        outdata += newf
        if (nf > 1 and i < nf - 1): outdata += ' \ \n'
        
        # Create the list of tuples (src, dst) for the links. If 'renamed' is
        # not set, link with old names.
        LinkData.append(('../' + f, newf))
            
    outdata += '\n'
    return (outdata, LinkData)

##
def set_poni (IndCal, description, swflag, swcase, newbasename, pname, data):
    '''Find p.o.n.i. files in current directory. If there is no one,
    replaces edf extension by 'poni' for silver behenate file and
    takes it as the valid one.

    '''

    # Initialize output string and links list.
    outdata  = '\n' + description['PONI'] + '# P.O.N.I. file(s)\n'
    LinkData = []
    
    # List of poni files in current directory.
    foundponifiles = [ f for f in sorted(glob.glob('*'), reverse=True)
                       if re.search('poni', f, re.I) ]

    # Test whether there are poni files.
    if (len(foundponifiles) == 0):
        print('\n WARNING: no \'poni\' files found in current directory.'
              + ' Maybe you should run XS_ponifile.py first. '
              + ' This parameter is mandatory.')

        proceed = input(' Should I proceed anyway? [y/N]')
        if (proceed != 'y'):
            print(' Aborting. ')
            sys.exit(1)

        # No mask files, but proceed. Return None.
        return None, None
        
    print('\n OBS.: found the following poni file(s) in current'
          +' directory:\n\t {}'.format(', '.join(foundponifiles)))
          
    if (len(foundponifiles) > 1):
        print('\n Using only the first match for PONI variable.')
        
    print(' Please, change this parameter manually if necessary.\n')

    # Output string and link list for poni files found.
    for poni in foundponifiles:

        # If poni file name is to be changed.
        if (poni in IndCal and swflag['renamed']):
            extra_info = '# Obs.: ' + data[item]['OBSV'] + '\n\n'
            newbasename = re.sub('[:\ ,]+', '_', poni)
            newdata, newlink = _output_template(poni,
                                                description,
                                                swflag,
                                                swcase,
                                                newbasename,
                                                pname,
                                                extra_info)
        else:
            newdata = f"{description['PONI']}\nPONI = {poni}"
            newlink = [ ('../' + poni, poni) ]
        # Store new values.
        # Leftmost newline is eliminated, so extra poni files can be properly
        # commented.
        outdata += re.sub('^\n', '', newdata) + '\n#'
        LinkData += newlink
                
    return outdata, LinkData

##
def set_direct_noise_shadow (IndCal, description, swflag, swcase, newbasename,
                             data):
    '''Create template for the shadow file (usually, glassy
    carbon). Return template text and list of links to be set.

    '''

    # Initialize output string and links list.
    outdata  = '\n' 
    LinkData = []
    
    # Relate calibrant files listed in spreadsheet with poni files found.
    for item in IndCal:
        
        D  = re.search('direct', item, re.I)
        N  = re.search('noise',  item, re.I)
        S  = re.search('glassy|shadow', item, re.I)

        # Skip shadow and direct beam for WAXS.
        if (swcase == 'waxs' and (D or S)): continue
        
        # Run over cases and register the ones found.
        for case in [ D, N, S ]:
            newdata, newlink = '', []
            if (case):
                # Get the parameter name.
                pname    = calib_param[case.group(0).lower()]
                outdata += description[pname] + '\n# ' + item.capitalize() + ' file.'
                
                outdata += '\n# In log file ({}): {}'.format(case.group(0).lower(), item)
                extra_info = '# Obs.: ' + data[item]['OBSV'] + '\n'
                #
                if (swflag['renamed']):
                    newbasename = re.sub('[:\ ,]+', '_', item)
                    newdata, newlink = _output_template(IndCal[item],
                                                        description, swflag,
                                                        swcase, newbasename, pname,
                                                        extra_info)
                #else:
                    #newdata = [ IndCal[item] ]
                    #newlink = [ IndCal[item], IndCal[item] ]

            try:
                # Store new values.
                outdata  += newdata
                LinkData += newlink
            except:
                pass
            
    return outdata, LinkData

##
def set_maskfiles (description, swflag):
    '''Create template for mask based on mask files in main measurement
    directory. Return template text and list of links to be set.

    '''

    outdata, LinkData = '', []
    
    # Mask file. Default = mask.txt.
    maskfiles = sorted(glob.glob('mask*'))
    if (len(maskfiles) == 0):
        print ('\n WARNING: no mask file found in current directory.'
               + ' Variable MASK will not be set. '
               + '\n You may set it manually or put a mask file'
               + ' in current directory and rerun this program.')
        
        proceed = input(' Should I proceed anyway? [y/N]')
        if (proceed != 'y'):
            print(' Quitting. ')
            sys.exit(1)

        # No mask files, but proceed. Return None.
        return None, None

    print ('\n OBS.: found the following mask file(s) in current'
           + ' directory:\n {}'.format(', '.join(maskfiles)))

    if (len(maskfiles) > 1):
        print('\n\t MASK parameter will be set with as the first one.')
    print('Please, change this parameter manually if necessary.\n')
        
    # Output text with MASK variable.
    outdata += '\n\n' + description['MASK']
    outdata += ('# Mask file(s) found in current directory: \n')
    for M in maskfiles:
        outdata += f'MASK = {M}\n#'
        # Link to mask files.
        LinkData += [ (f'../{M}', M) ]

    return outdata, LinkData

##
def set_norm (description, swflag):
    '''Return template for normalization and subtraction method.

    '''
    
    # Normalization method. Default = 1.0.
    Norm = swflag['normalization'] if (swflag['normalization'] != '') else 1.0
    outdata = (f"\n\n# Normalization. {description['NORM']}\nNORM = {Norm}\n")
    
    # Multiple buffer subtraction method.
    outdata += (f"\n# Buffer subtraction. {description['MULTISUBT']}"
                f"\nMULTISUBT = {swflag['multisubt']}\n")
    return outdata

##
def get_auxiliary (IndAux, ID):
    '''Identify buffer, empty and water files. Input:
    IndAux      : data about empty, water and buffer items.
    ID          : pattern key from sample or temperature for sample identification
    description : verbose information about parameter
    swflag      : set of flags to define output options
    '''
    
    # Extract begining of sample string. The first field before a ":"
    # is used as a matching attempt between samples and buffers.
    try:
        SamplePattern = re.findall('.*:', ID)[0].split(':')[0].strip()
    except:
        SamplePattern = ''

    # Dictionary of items found.
    AuxData = { item : [] for item in sample_auxiliary.values() }
    AuxList = { item : {} for item in sample_auxiliary.values() }

    # Try to guess the correct buffer/background, water and empty files for the
    # given sample by comparing substrings. Exclude the last field (obs.).

    # Extract all files related to each item.
    for k, V in IndAux.items():
        if (re.search('buffer', k, re.I)):
            AuxList['BACKGROUND'][k] = V
        elif (re.search('water', k, re.I)):
            AuxList['WATER'][k] = V
        elif (re.search('empty',  k, re.I)):
            AuxList['EMPTY'][k] = V

    # AuxList is a dictionary for each auxiliary data whose value is a
    # dictionary of the respective items.
    # Run through each auxiliary data.
    for Aux, Items in AuxList.items():
        # Run through each item data and try to identify SamplePattern in the
        # respective data.
        itemfound, generic_item = False, []
        for it, dat in Items.items():
            K = it.split(':')
            # No base pattern found, skip.
            if (len(K) <= 1):
                generic_item.append(dat)
                continue
            # 
            if (re.search(SamplePattern, K[0], re.I)):
                    AuxData[Aux] = dat
                    itemfound = True
                    
        if (not itemfound):
            AuxData[Aux] = generic_item[0]
            print(f'WARNING: no identification pattern for the "{Aux}"'
                  +f' item in sample "{ID}", adding the generic one'
                  +f' found anyway, "{generic_item[0][0]}".')

    return AuxData

##
def divide_data (data, swflag, swcase):
    '''Separate data into subdirectories, accordingly to the division
    criterion (sample or temperature). Build text with integration
    parameters to respective files and create link lists to actual
    files.

    Arguments are: 

    data   - the set to be printed to file
    swflag - dictionary of flags defining options
    swcase - flag (string), current data refers to 'saxs' or 'waxs'

    Returns the parameters text for each sample/temperature and the
    list of links to be created.

    '''

    # Select description dictionary.
    description = verbose_description if (swflag['verbose']) else simple_description
    
    # Output data and respective links.
    outdata, LinkData = {}, {}

    # Index dictionaries to organize data in subgroups if integration
    # parameters must be divided in multiple files (by sample or temperature).
    IndDiv, IndAux, IndCal = indexes(data, swflag)

    # Suffix for temperature if necessary.
    Tsuffix = 'oC' if (swflag['division'] == 'T') else ''

    # Templates for calibrants and other parameters.
    # P.O.N.I. files.
    outponi, LinkPoni = set_poni(IndCal, description, swflag, swcase,
                                 '', 'PONI', data)

    # Shadow file (usually glassy carbon).
    outdns, LinkDNS = set_direct_noise_shadow(IndCal, description, swflag,
                                              swcase, '', data)

    # MASK files.
    outmask, LinkMask = set_maskfiles(description, swflag)

    # NORMALIZATION and SUBTRACTION method.
    outnorm = set_norm(description, swflag)
    
    # Run over set for the given division criterion. Each IndDiv entry value
    # contains the set of file names for a given sample or temperature (the
    # division item).
    for IDK in sorted(IndDiv):

        # Initialize new name for output files (option '-r').
        newbasename = ''

        # Set new base name for files if required.
        if (swflag['renamed']):
            newbasename = re.sub('[:\ ,_]+', '-', IDK)

        # Template for SAMPLE.
        # Get complementary information (observations) and text-format it.
        txt = data[IDK]['OBSV']
        obsv = '# Obs.: {0}\n'.format(txt) if txt != '' else ''
        extra_info = '# ' + IDK + '\n' + obsv
        # Template.
        outsamp, LinkSamp = _output_template(IndDiv[IDK], description,
                                             swflag, swcase,
                                             newbasename, 'SAMPLE',
                                             extra_info)
        
        # Templates for EMPTY, WATER and BACKGROUND files.
        AuxData = get_auxiliary(IndAux, IDK)
        
        # Template of every buffer, empty or water file.
        outaux, LinkAux = '', []        
        for Item in sample_auxiliary.values():

            txt  = ' [not retrieved] '
            extra_info = '# ' + IDK + '\n'

            try:
                txt = AuxData[Item][-1]
                # Complementary info.
                obsv = '# Obs.: {}\n'.format(txt) if txt != '' else ''
                extra_info = '# ' + IDK + '\n' + obsv
                # Create item template.
                auxtmp, LinkTmp = _output_template(AuxData[Item][:-1],
                                                   description, swflag, swcase,
                                                   newbasename, Item,
                                                   extra_info)
            except:
                auxtmp, LinkTmp = '', []
            
            outaux  += auxtmp
            LinkAux += LinkTmp

        # Output text.
        hsh = 79 * '#'
        header = (f'{hsh}\n### {swcase.upper()} parameters file'
                  f' for integration.\n{hsh}\n')
        outdata[IDK] = (f'{header}{outsamp}{outaux}{outponi}'
                        f'{outdns}{outmask}{outnorm}')
        
        # List of links to be created.
        LinkData[IDK] = LinkSamp + LinkAux + LinkPoni + LinkDNS + LinkMask 

    return outdata, LinkData
    
##
def _linkfile(src, dst, param=None):
    '''Link files: dst to src.'''
    
    try:
        # Try to create link, if it does not exist.
        #linkto = os.readlink(src)
        os.symlink(src, dst)
    except Exception as err:
        print(f'\n WARNING: while creating link {dst} to {src}:\n\t{err}')
        if (param is not None):
            print('(link: {})'.format(param))
    return

##
def print_and_link (outdata, LinkData, swflag, parfilename):
    ''' Write out data to parameter file. 
     outdata     : text with parameters to be printed to file.
     LinkData    : list of filename tuples (src, dst) to create links.
     parfilename : parameter file name.
     swflag      : flags with command line options.

    '''

    # Run over samples/temperatures.
    for ODK in outdata:
        print(' Files and links for {:25s} '.format(ODK), end='')

        # All subdirectories of spreadsheet # swflag['index'] are
        # created under directory Treatment_<index>
        TREATDIR = 'Treatment_{:0>2}_{}/'.format(str(swflag['index']),
                                                 swflag['sheetname'])
        TREATDIR += re.sub('[:\ ,_]+', '_', ODK)
        TREATDIR += '/'

        # Create sample directory.
        try:
            os.makedirs(TREATDIR, 0o755)
        except OSError as err:
            # If the directory exists, skip it.
            if (err.errno == errno.EEXIST):
                pass
            else:
                print (f'\n ERROR: while creating {TREATDIR}: {err}')
                sys.exit(1)
                
        # Write parameter file to directory and create links.
        with open(TREATDIR + parfilename, 'w') as pfn:
            pfn.write(outdata[ODK])
            # Create links in TREATDIR. The '../' is necessary for
            # directories are created under Treatment_<index>
            for L in LinkData[ODK]:
                _linkfile('../' + L[0], TREATDIR + L[1], param = L)  # 
        print('\t done.')

    print('\n')
    return

##
def main ():
    
    # Get command line options.
    xlsxname, swflag = cmd_opt()

    # Title and opening screen
    title = 'Frame Integrator for SAXS Data Treatment'
    subheading = 'Complex Fluids Group, IF-USP, Brazil'
    opscreen = LFU.opening_screen('*', title, subheading, __author__,
                                  __email__, __date__, __copyright__,
                                  __version__, __status__)
    print(opscreen)
    
    # Tests whether log file exists.
    if (not os.path.exists(xlsxname)):
        print (f'\n ERROR: File \'{xlsxname}\' not found in current directory.'
               ' Aborting.')
        sys.exit(1)

    # Open xlsx workbook with xlrd library.
    try:
        wb = xlrd.open_workbook(xlsxname)
    except Exception as err:
        print (' ERROR: {}'.format(err))
        sys.exit(1)
    
    # Output generic messages confirming options.
    output_messages(xlsxname, wb, swflag)
    
    # Open workbook sheet. Check for SAXS / WAXS cases.
    ws = wb.sheet_by_index(swflag['index'])
    swflag['sheetname'] = ws.name
    
    SWcase = ws.cell(8, 2).value
    swflag['saxs'] = True if (re.search('saxs', SWcase, re.I)) else False
    swflag['waxs'] = True if (re.search('waxs', SWcase, re.I)) else False
    # Measurement regime (SAXS / WAXS) must be defined in spreadsheet,
    # otherwise, end program.
    if ((not swflag['saxs']) and (not swflag['waxs'])):
        print (' ERROR: no scattering configuration (SAXS / WAXS) defined.')
        print (f' Please, check the worksheet parameters (file {xlsxname}). Aborting.')
        sys.exit(1)

    # Get data from worksheet.
    dataS, dataW = get_data_from_worksheet(ws, swflag)

    # Divide data by criterion and print out data.
    # SAXS.
    if (swflag['saxs']):
        outdata, LinkData = divide_data(dataS, swflag, 'saxs')
        print_and_link(outdata, LinkData, swflag, 'saxs_parameters')

    # WAXS.
    if (swflag['waxs']):
        outdata, LinkData = divide_data(dataW, swflag, 'waxs')
        print_and_link(outdata, LinkData, swflag, 'waxs_parameters')

    print (' Attention: do not forget to set the ANGLES and QRADII', end='')
    print (' variables if necessary in saxs_parameters(s) file(s).')
        
    return 0

##
if __name__ == '__main__':
    main()
