#!/usr/bin/python3
# -*- coding: utf-8 -*-

'''Plot q x I(q) curves generated by XS-treatment suite.

Usage:
  This program is interactive, just run XS_curveplot.py

This script is part of the XS-treatment suite for SAXS/WAXS data
treatment.

'''

__version__   = '2.4.1'
__author__ = 'Dennys Reis & Arnaldo G. Oliveira-Filho'
__credits__ = 'Dennys Reis & Arnaldo G. Oliveira-Filho'
__email__ = 'dreis@if.usp.br, agolivei@if.usp.br'
__license__ = 'GPL'
__date__   = '2022-09-14'
__status__   = 'Development'
__copyright__ = 'Copyright 2022 by GFCx-IF-USP'
__local__ = 'GFCx-IF-USP'

import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import sys
import os
import re
import time

import platform
import imp

global saxspath

try: saxspath = imp.find_module("XS-treatment")
except NameError: print ("Error: The module XS-treatment was not installed.");

if platform.system()== "win32" or platform.system()== "Windows" :
    saxspath =saxspath[1]+'\\'
else :
    saxspath =saxspath[1]+'/'

sys.path.append(saxspath)


#sys.path.append('/usr/local/lib/XS-treatment/')
import XS_libfileutils as LFU

mpl.rc('mathtext',default='regular')
#plt.rcParams['font.size'] = 12.0

#
def on_click(event):
    '''Print coordinates on mouse click.'''
    # get the x and y coords
    x, y = event.x, event.y
    pf = open('qpos_analysis.txt', 'a')
    if (event.button == 3):
        if (event.inaxes is not None):
            qc = event.xdata
            dc = 2. * np.pi / qc
            Ic = event.ydata
            s = f' {qc:^15.5f} \t {dc:^15.2f} \t {Ic:^15.3e}\n'
            print(s)
            pf.write(s)
            pf.close()

#
def plot_curves_menu():
    '''Ask plotting options. Get file names, plot scaling and
    normalization, saving and point-clcking options.'''
    
    # Choose images files to add
    filelist = LFU.show_filenames('rad', 'RAD', 'rds', 'RDS', 'rsr', 'RSR',
                                  'rdn', 'RDN', 'dat', 'DAT', mandatory=True,
                                  instruction=True)
    s = ' Choose image files to plot:'
    filenames = LFU.read_filenames(filelist, s, mandatory=True)
    
    # Options for curve plot
    LFU.section_separator('*','Options for Image Plot')
    
    # Option: ...
    print (' Choose plot type:')
    scales_options = [ '   1) x = lin, y = lin',
                       '   2) x = lin, y = log',
                       '   3) x = log, y = lin',
                       '   4) x = log, y = log' ]
    
    scale = LFU.menu_closed_options(scales_options)
    
    if   (scale == '1'):
        xscale = 'linear'
        yscale = 'linear'
    elif (scale == '2'):
        xscale = 'linear'
        yscale = 'log'
    elif (scale == '3'):
        xscale = 'log'
        yscale = 'linear'
    elif (scale == '4'):
        xscale = 'log'
        yscale = 'log'
    
    # Option: normalized curve.
    # Per detector count.
    normal = input('\n Normalize curves per \'Detector\' in files\' header? [y/N] ')
    normalizeD = True if (normal == 'y' or normal == 'Y') else False

    # Per time.
    normal = input('\n Normalized curves per \'Time\' in files\' header)? [y/N] ')
    normalizeT = True if (normal == 'y' or normal == 'Y') else False

    # Option: save image?
    saveimg = input('\n Save image? [y/N] ')
    saveimage = True if (saveimg == 'y' or saveimg == 'Y') else False
        
    # Option: simple point analysis?
    qanalysis = input('\n Point click analysis? [y/N] ')
    qanalysis = True if (qanalysis == 'y') else False

    
    '''
    # Option: single or multiple figures?
    print (' Single or multiple figures?')
    figs_options = ['   1) Single figure',
                    '   2) Multiple figure']
    
    scale = LFU.menu_closed_options(scales_options)
    
    if   opt=='1': num=0
    elif opt=='2': num=None
    '''
    
    # Dictionary of figures' options
    fdict = {'cxlabel' : r'$q\,[\AA^{-1}]$',
             'cylabel' : r'$I(q)\,[cm^{-1}]$',
             'cxscale' : xscale,
             'cyscale' : yscale,
             'cnormalizationD' : normalizeD,
             'cnormalizationT' : normalizeT,
             'csave' : saveimage,
             'point_analysis' : qanalysis}

    return filenames, fdict

##
def point_analysis (curvefile, plt):
    '''Set point-click-analysis output format.'''
    
    tm = time.strftime("%Y-%m-%d %H:%M:%S")
    with open('qpos_analysis.txt', 'a+') as posfile:
        
        s = '''
 Directory: {0}
 File:      {1}
 Date:      {2}

 *** OBS.: Right-click points to get their coordinates. ***

 {3:^15} \t {4:^15} \t {5:^15}
'''.format(os.getcwd(), curvefile, tm, 'q(A-1)', 'd(Angstrom)', 'I(a.u.)')

        print(s)
        posfile.write(s)
    #
    binding_id = plt.connect('button_press_event', on_click)
    if ("test_disconnect" in sys.argv):
        print("Disconnecting console coordinate printout...")
        plt.disconnect(binding_id)
    return

#
def read_curve_file (curvefile):

    # Retrieve data from file.
    # This method is necessary to get header info.
    with open(curvefile, 'r') as curve:
        datacurve = curve.read().splitlines()
    
    try:
        # Get header info (Time and Detector) from second line.
        line2 = re.sub('#', '', datacurve[1]).split()
        Time, detector = float(line2[0]), float(line2[1])
        # Retrieve data from file using numpy.
        q, I, sigma = np.genfromtxt(curvefile, comments='#',
                                    usecols=(0,1,2), unpack=True)
    except Exception as err:
        # Try to get data from 2 or 3 columns and ignore header.
        print(f' WARNING: {err}'
              '\n Trying to read from file anyway,'
              ' but will ignore header info (Time and Detector).')
        
        q, I, sigma = [], [], []
        Time, detector = 1.0, 1.0
        fnum = '\ *[-+0-9.e]+'     # Pattern: flop with spaces.
        pat = f'^({fnum}){{3}}'    # 3 flops.
        # Run through data skipping header.
        for L in datacurve[3:]:
            if (re.match('^#', L)): continue  # Skip comment.
            data = re.match(pat, L)
            if data is None: continue         # Skip if no match.
            # Extract numbers from line and append to arrays.
            dfields = data.group(0).split()
            d = [ float(x) for x in dfields if x != '' ]
            if (d[1] != 0.0):    # Skip if I = 0.
                q.append(d[0])
                I.append(d[1])
                s = 0.01 * d[1] if len(d) == 2 else d[2]
                sigma.append(s)

    if (len(q) == 0):
        print('\n WARNING: could not retrieve information'
              f' from file {curvefile}.')
                        
    return (np.array(q), np.array(I), np.array(sigma), Time, detector)
        
##
def plot_curves(curvefiles, fdict):
    '''
    '''
    
    #Create figure window to plot data
    fig = plt.figure(figsize=(15, 15))
    fig.tight_layout()
    ax = fig.add_subplot(1,1,1)
    ax.set_xlabel(fdict['cxlabel'])
    ax.set_ylabel(fdict['cylabel'])
    ax.set_xscale(fdict['cxscale'])
    ax.set_yscale(fdict['cyscale'])

    # Loop over files 
    for curvefile in curvefiles:
        print(f'\n Reading data from file {curvefile} ...', end=' ')
        q, I, sigma, Time, detector = read_curve_file(curvefile)
        print('done.')

        # Normalization option
        if (not fdict['cnormalizationD']): detector = 1.
        if (not fdict['cnormalizationT']): Time = 1.
        norm = 1. / (Time * detector)
        print (" Normalization factor for {}: {:>20}".format(curvefile, norm))

        # Plot graph with error bars.
        ax.errorbar(q, I * norm, yerr=sigma * norm, fmt='o-', ms=3.,
                    label=curvefile)

        # Save figure.
        if (fdict['csave']): fig.savefig(curvefile.split('.')[0] + '.png')

        # Point-click analysis.
        if (fdict['point_analysis']): point_analysis(curvefile, plt)
            
    ax.legend(loc=0, numpoints=2)
    plt.title("")
    plt.tight_layout()
    plt.show()
    plt.close(fig)

    return
    
##
def main ():
    '''Call interactive menu and plot curves with due options.'''

    try:
        if (sys.argv[1] == '-h'):
            help('XS_curveplot')
            return
    except:
        pass
    
    # Title and opening screen
    title = 'Plot curver from SAXS Data Treatment'
    subheading = 'Complex Fluids Group, IF-USP, Brazil'
    opscreen = LFU.opening_screen('*', title, subheading, __author__,
                                   __email__, __date__, __copyright__,
                                   __version__, f'({__status__})')
    print(opscreen)

    # Get curves to be plotted.
    filenames, fdict = plot_curves_menu()
    # Plot curves.
    plot_curves(filenames, fdict)

    return
    
#
if __name__ == "__main__":
    main()
