/*
  This file contains the protocol buffer definition for all the models
  defined in a deployment of the TXP system.

  This entities are mapped directly to the stored entities in some database.
  For example, Firestore.

  To ensure cohesion with the Database and In-Memory instanced objects,
  protobuf message fields will have the
  same name as the column/key name in the database.
 */
syntax = "proto3";
import "google/protobuf/descriptor.proto";

// Just a constant enum with a value that handles a versioning for this models
enum VERSION {
  V1=0;
}

/******************* DEFINITION of nested entities and small concepts ********************************/

/**
* EntityFieldRequiredByEnum

Enumeration value to describe the "nature" of a field
for a given entity.

This allows to discern when to return the value over the network for a
client network operation.
*/
enum EntityFieldRequiredByEnum {
    ALWAYS_REQUIRED = 0;
    WEB_REQUIRED = 1;
    MACHINE_LEARNING_REQUIRED = 2;
    IOT_DEVICES_REQUIRED = 3;
}

/**
AssetKind enumeration to describe the observed asset type.

Note: This is note used yet. But we should include in the system
  modelling for different types of engine machines.
 */
enum AssetKindEnum {
  CONVEYOR_ENGINE=0;
  OBSERVABLE_ASSET=1;
}

enum PerceptionNameEnum {
  Invalid=0;
  VibrationAcceleration=2;
  VibrationSpeed=1;
  VibrationMock=3;
  Temperature=4;
  Microphone=5;
  Magnetometer=6;
  ThermalImage=7;
  ImageNormal=8;
  ImageMock=9;
}

/**
  VibrationMockComponentsProto message is used by the MockDriver
  utility.
 */
message VibrationMockComponentsProto {
  int32 amplitude = 1;
  string component_type = 2;
  int32 frequency = 3;
  int32 phase = 4;
}

/**
  All Perceptions will be handled by this PerceptionProto.

  To avoid over-complicating, we take advantage of optional values and the `name` field.
 */
message PerceptionProto {
  PerceptionNameEnum name = 1;
  repeated int32 dimensions = 2;

  /*The mode to be processed in dataflow pipeline*/
  int32 mode = 3;

  /*Used by sensors that captures vibration, etc...*/
  optional float sampling_frequency = 4;

  /*Used by image-capturing devices like arm robot*/
  repeated int32 resolution = 5;

  /*Used by image-capturing devices like arm robot*/
  optional string format = 6;

  /*Optional components definition for Vibration Mock*/
  repeated VibrationMockComponentsProto components_per_dimension = 7;
}

/**
  A Physical Sensor is a field of the parameters configuration for a
  Virtual Arm robot device
 */
message PhysicalSensorProto {
  string camera_type = 1;
  string physical_id = 2;
}

/**
  A Virtual Device contains the specific information for a DofBot Virtual
    positioned device
 */
message VirtualDeviceProto {
  repeated int32 position = 1;
  string virtual_id_hash = 2;
}

/**
  The Device Parameters for an Edge from the TXP system.

  New fields can be added here and we can use the dynamic optional
    possibilities of Protocol Buffer to keep it simple!
 */
message DeviceParametersProto {
  string physical_id = 1;
  repeated PhysicalSensorProto sensors = 2;
  optional VirtualDeviceProto virtual_device=3;
}


/**
  A Proto to contain the representation of a Sampling Window
 */
message SamplingWindowProtob {
  int32 observation_time=1;
  int32 sampling_time=2;
}

/**
  The sampling parameters structure for a Gateway Sampling Scheduled Job
 */
message SamplingJobParametersProto {
  string active_week_days = 1;
  string start_date = 2;
  string end_date = 3;
  string start_time = 4;
  string end_time = 5;
  repeated string predicates = 6;
  SamplingWindowProtob sampling_window = 7;
}

message SamplingJobTaskProto {
  repeated string assets = 1;
  SamplingJobParametersProto parameters = 2;
}

message SamplingJobProto {
  SamplingJobParametersProto parameters = 1;
  repeated SamplingJobTaskProto tasks = 2;
  string telemetry_rollover_policy=500; // legacy field
  string job_id=4;
}


/******************* DEFINITION of Main TXP entities ********************************/

/**
FieldOptions extension `required_by`

Used to describe the field values of the main TXP entities.

This allows to discern when to return the value over the network for a network operation.
 */
extend google.protobuf.FieldOptions {
  EntityFieldRequiredByEnum required_by = 5001;
}

/*
  AssetMetricsProto represents the computed asset discrete metrics to shown in
    the dashboard tools for a machine.
 */
message AssetMetricsProto {
  string asset_type = 1 [ (required_by)=WEB_REQUIRED ];
  string last_seen = 2 [ (required_by)=WEB_REQUIRED ];
  float rpm = 3 [ (required_by)=WEB_REQUIRED ];
  float temperature = 4 [ (required_by)=WEB_REQUIRED ];
  float worked_hours = 5 [ (required_by)=WEB_REQUIRED ];
  string asset_id = 6 [ (required_by)=WEB_REQUIRED ];
}


/**
AssetsGroupProto to represent the
machines group entity.
 */
message AssetsGroupProto {
  string name = 1 [ (required_by)=ALWAYS_REQUIRED ];
  string address = 2 [ (required_by)=ALWAYS_REQUIRED ] ;
  repeated string assets = 3 [ (required_by)=ALWAYS_REQUIRED ];
}


/**
AssetProto to represent the machines group entity.

TODO The tasks field is not modelled yet. The gRCP entities
  will be used first for the web clients. If everything works
  as expected, we should model the machine learning tasks in a
  proto idiomatic way and update this entities.

TODO: ADD assets typification and conveyors engines information.
 */
message AssetProto {
  string asset_id = 1 [ (required_by)=ALWAYS_REQUIRED ];
  string state_manager = 4 [ (required_by)=MACHINE_LEARNING_REQUIRED ];
  repeated string associated_with_edges=6;
  // map<string, string> tasks = 5 [ (required_by)=MACHINE_LEARNING_REQUIRED ];
}


/**
Edges Proto to represent the Edge entity.

TODO  If everything works as expected, we should model the
  type and kind as enumerated field in a protobuf idiomatic way

TODO support Devices Parameters / Virtual Devices devices in this proto contract

 */
message EdgeProto {
  string logical_id = 1 [ (required_by)=ALWAYS_REQUIRED ];
  string device_kind = 2 [ (required_by)=ALWAYS_REQUIRED ];
  string type = 3 [ (required_by)=ALWAYS_REQUIRED ];
  DeviceParametersProto parameters = 4 [ (required_by)=IOT_DEVICES_REQUIRED ];
  map<string, PerceptionProto> perceptions = 5 [ (required_by)=IOT_DEVICES_REQUIRED ];
}


/**
Device Proto to represent the Device general entity.
A Device is just the concept to represent the default values
for an specific kind of Edge.

TODO  If everything works as expected, we should model the
  type and kind as enumerated field in a protobuf idiomatic way

TODO support Devices Parameters / Virtual Devices devices in this proto contract

 */
message DeviceProto {
  string kind = 1 [ (required_by)=ALWAYS_REQUIRED ];
  string type = 2 [ (required_by)=ALWAYS_REQUIRED ];
  DeviceParametersProto  parameters = 3 [ (required_by)=IOT_DEVICES_REQUIRED ];
  map<string, PerceptionProto> perceptions = 4 [ (required_by)=IOT_DEVICES_REQUIRED ];
}


/**
Gateway Proto to represent the Gateway entity

TODO If everything works as expected, we should model the
 job field in a Proto idiomatic way
 */
message GatewayProto {
  string gateway_id = 1 [ (required_by)=ALWAYS_REQUIRED ];
  string cloud_region = 2 [ (required_by)=ALWAYS_REQUIRED ];
  repeated string assets = 3 [ (required_by)=ALWAYS_REQUIRED ];
  string project_id = 4 [ (required_by)=ALWAYS_REQUIRED ];
  string registry_id = 5 [ (required_by)=ALWAYS_REQUIRED ];
  string has_job = 6 [ (required_by) = IOT_DEVICES_REQUIRED ];
  string tenant_id = 7 [ (required_by) = ALWAYS_REQUIRED ];
}


