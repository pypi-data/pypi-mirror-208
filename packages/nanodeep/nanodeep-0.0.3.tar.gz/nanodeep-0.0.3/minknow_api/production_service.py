### THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY ###
import minknow_api
from minknow_api.production_pb2_grpc import *
import minknow_api.production_pb2 as production_pb2
from minknow_api.production_pb2 import *
from minknow_api._support import MessageWrapper, ArgumentError
import time
import logging
import sys

__all__ = [
    "ProductionService",
    "WriteFlowcellDataRequest",
    "WriteFlowcellDataResponse",
    "WriteFlowcellIdRequest",
    "WriteFlowcellIdResponse",
    "WriteWellsPerChannelRequest",
    "WriteWellsPerChannelResponse",
    "WriteProductCodeRequest",
    "WriteProductCodeResponse",
    "WriteTemperatureOffsetRequest",
    "WriteTemperatureOffsetResponse",
]

def run_with_retry(method, message, timeout, unwraps, full_name):
    retry_count = 20
    error = None
    for i in range(retry_count):
        try:
            result = MessageWrapper(method(message, timeout=timeout), unwraps=unwraps)
            return result
        except grpc.RpcError as e:
            # Retrying unidentified grpc errors to keep clients from crashing
            retryable_error = (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details() or \
                                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()))
            if retryable_error:
                logging.info('Bypassed ({}: {}) error for grpc: {}. Attempt {}.'.format(e.code(), e.details(), full_name, i))
            else:
                raise
            error = e
        time.sleep(1)
    raise error


class ProductionService(object):
    """Methods used in production.

    These might modify the device or flowcell permanently. They are not available
    in non-production contexts."""
    def __init__(self, channel):
        self._stub = ProductionServiceStub(channel)
        self._pb = production_pb2
    def write_flowcell_data(self, _message=None, _timeout=None, **kwargs):
        """Writes data to the EEPROM on the attached flowcell.

        This call will fail with FAILED_PRECONDITION if there is no device connected or no flowcell
        attached.

        Very little checking of the provided values is done, and no attempt is made to preserve
        existing data. Use the other methods on this service for that.

        This RPC is idempotent. It may change the state of the system, but if the requested
        change has already happened, it will not fail because of this, make any additional
        changes or return a different value.

        Args:
            _message (minknow_api.production_pb2.WriteFlowcellDataRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.
            empty (minknow_api.production_pb2.WriteFlowcellDataRequest.Empty, optional): Clears any existing data from the EEPROM.
            v1 (minknow_api.production_pb2.WriteFlowcellDataRequest.Version1, optional): Writes version 1 data to the EEPROM.
            v2 (minknow_api.production_pb2.WriteFlowcellDataRequest.Version2, optional): Writes version 2 data to the EEPROM.
            v3 (minknow_api.production_pb2.WriteFlowcellDataRequest.Version3, optional): Writes version 3 data to the EEPROM.
            v4 (minknow_api.production_pb2.WriteFlowcellDataRequest.Version4, optional): Writes version 4 data to the EEPROM.
            v5 (minknow_api.production_pb2.WriteFlowcellDataRequest.Version5, optional): Writes version 5 data to the EEPROM.
            v6 (minknow_api.production_pb2.WriteFlowcellDataRequest.Version6, optional): Writes version 6 data to the EEPROM.

        Returns:
            minknow_api.production_pb2.WriteFlowcellDataResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.write_flowcell_data,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.production.ProductionService")

        unused_args = set(kwargs.keys())

        # check oneof group 'data'
        oneof_fields = set([
            "empty",
            "v1",
            "v2",
            "v3",
            "v4",
            "v5",
            "v6",
        ])

        if len(unused_args & oneof_fields) > 1:
            raise ArgumentError("write_flowcell_data given multiple conflicting arguments: '{}'".format(", ".join(unused_args & oneof_fields)))

        _message = WriteFlowcellDataRequest()

        if "empty" in kwargs:
            unused_args.remove("empty")
            _message.empty.CopyFrom(kwargs['empty'])

        if "v1" in kwargs:
            unused_args.remove("v1")
            _message.v1.CopyFrom(kwargs['v1'])

        if "v2" in kwargs:
            unused_args.remove("v2")
            _message.v2.CopyFrom(kwargs['v2'])

        if "v3" in kwargs:
            unused_args.remove("v3")
            _message.v3.CopyFrom(kwargs['v3'])

        if "v4" in kwargs:
            unused_args.remove("v4")
            _message.v4.CopyFrom(kwargs['v4'])

        if "v5" in kwargs:
            unused_args.remove("v5")
            _message.v5.CopyFrom(kwargs['v5'])

        if "v6" in kwargs:
            unused_args.remove("v6")
            _message.v6.CopyFrom(kwargs['v6'])

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to write_flowcell_data: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.write_flowcell_data,
                              _message, _timeout,
                              [],
                              "minknow_api.production.ProductionService")
    def write_flowcell_id(self, _message=None, _timeout=None, **kwargs):
        """Write the flowcell ID to the flowcell EEPROM.

        Flowcell IDs over 8 characters or containing unprintable characters will be rejected with
        INVALID_ARGUMENT. An empty string effectively clears the flowcell ID.

        If nothing is currently written on the flowcell EEPROM, it will write the data in a suitable
        format. If the EEPROM contains a data version that supports this field, it will be updated,
        and all other fields will be preserved. If the EEPROM contains a data version that doesn't
        support this field, this call will fail with FAILED_PRECONDITION and the EEPROM will not be
        changed.

        This call will fail with FAILED_PRECONDITION if there is no device connected or no flowcell
        attached, or if the flowcell's EEPROM is corrupt or has data in an unknown version.

        This RPC is idempotent. It may change the state of the system, but if the requested
        change has already happened, it will not fail because of this, make any additional
        changes or return a different value.

        Args:
            _message (minknow_api.production_pb2.WriteFlowcellIdRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.
            flowcell_id (str, optional): 

        Returns:
            minknow_api.production_pb2.WriteFlowcellIdResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.write_flowcell_id,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.production.ProductionService")

        unused_args = set(kwargs.keys())

        _message = WriteFlowcellIdRequest()

        if "flowcell_id" in kwargs:
            unused_args.remove("flowcell_id")
            _message.flowcell_id = kwargs['flowcell_id']

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to write_flowcell_id: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.write_flowcell_id,
                              _message, _timeout,
                              [],
                              "minknow_api.production.ProductionService")
    def write_wells_per_channel(self, _message=None, _timeout=None, **kwargs):
        """Write the number of wells to the flowcell EEPROM.

        Well counts greater than the number supported by the hardware will be rejected. Passing zero
        will effectively set it to the default for this device.

        If nothing is currently written on the flowcell EEPROM, it will write the data in a suitable
        format. If the EEPROM contains a data version that supports this field, it will be updated,
        and all other fields will be preserved. If the EEPROM contains a data version that doesn't
        support this field, this call will fail with FAILED_PRECONDITION and the EEPROM will not be
        changed.

        This call will fail with FAILED_PRECONDITION if there is no device connected or no flowcell
        attached, or if the flowcell's EEPROM is corrupt or has data in an unknown version.

        This RPC is idempotent. It may change the state of the system, but if the requested
        change has already happened, it will not fail because of this, make any additional
        changes or return a different value.

        Args:
            _message (minknow_api.production_pb2.WriteWellsPerChannelRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.
            wells_per_channel (int, optional): 

        Returns:
            minknow_api.production_pb2.WriteWellsPerChannelResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.write_wells_per_channel,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.production.ProductionService")

        unused_args = set(kwargs.keys())

        _message = WriteWellsPerChannelRequest()

        if "wells_per_channel" in kwargs:
            unused_args.remove("wells_per_channel")
            _message.wells_per_channel = kwargs['wells_per_channel']

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to write_wells_per_channel: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.write_wells_per_channel,
                              _message, _timeout,
                              [],
                              "minknow_api.production.ProductionService")
    def write_product_code(self, _message=None, _timeout=None, **kwargs):
        """Write the product code to the flowcell EEPROM.

        This is the code presented to customers in the shop, eg: "FLO-MIN106".

        Produce codes over 10 characters or containing unprintable characters will be rejected with
        INVALID_ARGUMENT. An empty string effectively clears the product code.

        If nothing is currently written on the flowcell EEPROM, it will write the data in a suitable
        format. If the EEPROM contains a data version that supports this field, it will be updated,
        and all other fields will be preserved. If the EEPROM contains a data version that doesn't
        support this field, this call will fail with FAILED_PRECONDITION and the EEPROM will not be
        changed.

        This call will fail with FAILED_PRECONDITION if there is no device connected or no flowcell
        attached, or if the flowcell's EEPROM is corrupt or has data in an unknown version.

        This RPC is idempotent. It may change the state of the system, but if the requested
        change has already happened, it will not fail because of this, make any additional
        changes or return a different value.

        Args:
            _message (minknow_api.production_pb2.WriteProductCodeRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.
            product_code (str, optional): 

        Returns:
            minknow_api.production_pb2.WriteProductCodeResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.write_product_code,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.production.ProductionService")

        unused_args = set(kwargs.keys())

        _message = WriteProductCodeRequest()

        if "product_code" in kwargs:
            unused_args.remove("product_code")
            _message.product_code = kwargs['product_code']

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to write_product_code: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.write_product_code,
                              _message, _timeout,
                              [],
                              "minknow_api.production.ProductionService")
    def write_temperature_offset(self, _message=None, _timeout=None, **kwargs):
        """Write the temperature offset to the flowcell EEPROM.

        The temperature offset is specified in hundreths of a degree Celsius, and can range from
        -327.67 degrees Celsius to 327.67 degrees Celsius. The value -32767 will be accepted, but
        will cause the temperature offset to cleared, just as though no value had been provided at
        all.

        If nothing is currently written on the flowcell EEPROM, it will write the data in a suitable
        format. If the EEPROM contains a data version that supports this field, it will be updated,
        and all other fields will be preserved. If the EEPROM contains a data version that doesn't
        support this field, this call will fail with FAILED_PRECONDITION and the EEPROM will not be
        changed.

        This call will fail with FAILED_PRECONDITION if there is no device connected or no flowcell
        attached, or if the flowcell's EEPROM is corrupt or has data in an unknown version.

        This RPC is idempotent. It may change the state of the system, but if the requested
        change has already happened, it will not fail because of this, make any additional
        changes or return a different value.

        Args:
            _message (minknow_api.production_pb2.WriteTemperatureOffsetRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.
            offset (int, optional): 

        Returns:
            minknow_api.production_pb2.WriteTemperatureOffsetResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.write_temperature_offset,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.production.ProductionService")

        unused_args = set(kwargs.keys())

        _message = WriteTemperatureOffsetRequest()

        if "offset" in kwargs:
            unused_args.remove("offset")
            _message.offset = kwargs['offset']

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to write_temperature_offset: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.write_temperature_offset,
                              _message, _timeout,
                              [],
                              "minknow_api.production.ProductionService")
