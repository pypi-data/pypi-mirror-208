{"version":3,"file":"chunks/app_utils_discover_discoverQuery_tsx-app_views_starfish_components_chart_tsx-app_views_starfi-a0d6ab.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/components/charts/areaChart.tsx","webpack:///./app/components/charts/series/areaSeries.tsx","webpack:///./app/components/charts/components/dataZoomSlider.tsx","webpack:///./app/components/charts/chartZoom.tsx","webpack:///./app/components/charts/components/dataZoomInside.tsx","webpack:///./app/components/charts/components/toolBox.tsx","webpack:///./app/utils/discover/discoverQuery.tsx","webpack:///./app/components/charts/series/scatterSeries.tsx","webpack:///./app/views/starfish/components/chart.tsx","webpack:///./app/views/starfish/utils/dates.tsx","webpack:///./app/views/starfish/utils/zeroFillSeries.tsx"],"sourcesContent":["import type {LineSeriesOption} from 'echarts';\n\nimport {Series} from 'sentry/types/echarts';\n\nimport AreaSeries from './series/areaSeries';\nimport BaseChart from './baseChart';\n\ntype ChartProps = Omit<React.ComponentProps<typeof BaseChart>, 'css'>;\n\nexport type AreaChartSeries = Series & Omit<LineSeriesOption, 'data' | 'name'>;\n\nexport interface AreaChartProps extends Omit<ChartProps, 'series'> {\n  series: AreaChartSeries[];\n  additionalSeries?: LineSeriesOption[];\n  stacked?: boolean;\n}\n\nexport function AreaChart({series, stacked, colors, ...props}: AreaChartProps) {\n  return (\n    <BaseChart\n      {...props}\n      data-test-id=\"area-chart\"\n      colors={colors}\n      series={series.map(({seriesName, data, ...otherSeriesProps}, i) =>\n        AreaSeries({\n          stack: stacked ? 'area' : undefined,\n          name: seriesName,\n          data: data.map(({name, value}) => [name, value]),\n          lineStyle: {\n            color: colors?.[i],\n            opacity: 1,\n            width: 0.4,\n          },\n          areaStyle: {\n            color: colors?.[i],\n            opacity: 1.0,\n          },\n          animation: false,\n          animationThreshold: 1,\n          animationDuration: 0,\n          ...otherSeriesProps,\n        })\n      )}\n    />\n  );\n}\n","import type {LineSeriesOption} from 'echarts';\n\nimport LineSeries from 'sentry/components/charts/series/lineSeries';\n\nexport default function AreaSeries(props: LineSeriesOption = {}): LineSeriesOption {\n  return LineSeries({\n    ...props,\n  });\n}\n","import 'echarts/lib/component/dataZoomSlider';\n\nimport type {SliderDataZoomComponentOption} from 'echarts';\n\nconst DEFAULT: SliderDataZoomComponentOption = {\n  realtime: false,\n  showDetail: false,\n  left: 0,\n  right: 6,\n  bottom: 8,\n};\n\nexport default function DataZoomSlider(\n  props: SliderDataZoomComponentOption | SliderDataZoomComponentOption[]\n): SliderDataZoomComponentOption[] {\n  // `props` can be boolean, if so return default\n  if (!props || !Array.isArray(props)) {\n    const dataZoom = {\n      ...DEFAULT,\n      ...props,\n    };\n    return [dataZoom];\n  }\n\n  return props;\n}\n","import {Component} from 'react';\nimport {InjectedRouter} from 'react-router';\nimport type {\n  DataZoomComponentOption,\n  InsideDataZoomComponentOption,\n  ToolboxComponentOption,\n  XAXisComponentOption,\n} from 'echarts';\nimport moment from 'moment';\nimport * as qs from 'query-string';\n\nimport {updateDateTime} from 'sentry/actionCreators/pageFilters';\nimport DataZoomInside from 'sentry/components/charts/components/dataZoomInside';\nimport DataZoomSlider from 'sentry/components/charts/components/dataZoomSlider';\nimport ToolBox from 'sentry/components/charts/components/toolBox';\nimport {DateString} from 'sentry/types';\nimport {\n  EChartChartReadyHandler,\n  EChartDataZoomHandler,\n  EChartFinishedHandler,\n  EChartRestoreHandler,\n} from 'sentry/types/echarts';\nimport {callIfFunction} from 'sentry/utils/callIfFunction';\nimport {getUtcDateString, getUtcToLocalDateObject} from 'sentry/utils/dates';\n\nconst getDate = date =>\n  date ? moment.utc(date).format(moment.HTML5_FMT.DATETIME_LOCAL_SECONDS) : null;\n\ntype Period = {\n  end: DateString;\n  period: string | null;\n  start: DateString;\n};\n\nconst ZoomPropKeys = [\n  'period',\n  'xAxis',\n  'onChartReady',\n  'onDataZoom',\n  'onRestore',\n  'onFinished',\n] as const;\n\nexport type ZoomRenderProps = Pick<Props, (typeof ZoomPropKeys)[number]> & {\n  dataZoom?: DataZoomComponentOption[];\n  end?: Date;\n  isGroupedByDate?: boolean;\n  showTimeInTooltip?: boolean;\n  start?: Date;\n  toolBox?: ToolboxComponentOption;\n  utc?: boolean;\n};\n\ntype Props = {\n  children: (props: ZoomRenderProps) => React.ReactNode;\n  chartZoomOptions?: DataZoomComponentOption;\n  disabled?: boolean;\n  end?: DateString;\n  onChartReady?: EChartChartReadyHandler;\n  onDataZoom?: EChartDataZoomHandler;\n  onFinished?: EChartFinishedHandler;\n  onRestore?: EChartRestoreHandler;\n  onZoom?: (period: Period) => void;\n  period?: string | null;\n  router?: InjectedRouter;\n  showSlider?: boolean;\n  start?: DateString;\n  usePageDate?: boolean;\n  utc?: boolean | null;\n  xAxis?: XAXisComponentOption;\n  xAxisIndex?: number | number[];\n};\n\n/**\n * This is a very opinionated component that takes a render prop through `children`. It\n * will provide props to be passed to `BaseChart` to enable support of zooming without\n * eCharts' clunky zoom toolboxes.\n *\n * This also is very tightly coupled with the Global Selection Header. We can make it more\n * generic if need be in the future.\n */\nclass ChartZoom extends Component<Props> {\n  constructor(props: Props) {\n    super(props);\n\n    // Zoom history\n    this.history = [];\n\n    // Initialize current period instance state for zoom history\n    this.saveCurrentPeriod(props);\n  }\n\n  componentDidUpdate() {\n    if (this.props.disabled) {\n      return;\n    }\n\n    // When component updates, make sure we sync current period state\n    // for use in zoom history\n    this.saveCurrentPeriod(this.props);\n  }\n\n  history: Period[];\n  currentPeriod?: Period;\n  zooming: (() => void) | null = null;\n\n  /**\n   * Save current period state from period in props to be used\n   * in handling chart's zoom history state\n   */\n  saveCurrentPeriod = props => {\n    this.currentPeriod = {\n      period: props.period,\n      start: getDate(props.start),\n      end: getDate(props.end),\n    };\n  };\n\n  /**\n   * Sets the new period due to a zoom related action\n   *\n   * Saves the current period to an instance property so that we\n   * can control URL state when zoom history is being manipulated\n   * by the chart controls.\n   *\n   * Saves a callback function to be called after chart animation is completed\n   */\n  setPeriod = ({period, start, end}, saveHistory = false) => {\n    const {router, onZoom, usePageDate} = this.props;\n    const startFormatted = getDate(start);\n    const endFormatted = getDate(end);\n\n    // Save period so that we can revert back to it when using echarts \"back\" navigation\n    if (saveHistory) {\n      this.history.push(this.currentPeriod!);\n    }\n\n    // Callback to let parent component know zoom has changed\n    // This is required for some more perceived responsiveness since\n    // we delay updating URL state so that chart animation can finish\n    //\n    // Parent container can use this to change into a loading state before\n    // URL parameters are changed\n    onZoom?.({\n      period,\n      start: startFormatted,\n      end: endFormatted,\n    });\n\n    this.zooming = () => {\n      if (usePageDate && router) {\n        const newQuery = {\n          ...router.location.query,\n          pageStart: start ? getUtcDateString(start) : undefined,\n          pageEnd: end ? getUtcDateString(end) : undefined,\n          pageStatsPeriod: period ?? undefined,\n        };\n\n        // Only push new location if query params has changed because this will cause a heavy re-render\n        if (qs.stringify(newQuery) !== qs.stringify(router.location.query)) {\n          router.push({\n            pathname: router.location.pathname,\n            query: newQuery,\n          });\n        }\n      } else {\n        updateDateTime(\n          {\n            period,\n            start: startFormatted\n              ? getUtcToLocalDateObject(startFormatted)\n              : startFormatted,\n            end: endFormatted ? getUtcToLocalDateObject(endFormatted) : endFormatted,\n          },\n          router,\n          {skipDesyncUpdate: true}\n        );\n      }\n\n      this.saveCurrentPeriod({period, start, end});\n    };\n  };\n\n  /**\n   * Enable zoom immediately instead of having to toggle to zoom\n   */\n  handleChartReady = chart => {\n    this.props.onChartReady?.(chart);\n  };\n\n  /**\n   * Restores the chart to initial viewport/zoom level\n   *\n   * Updates URL state to reflect initial params\n   */\n  handleZoomRestore = (evt, chart) => {\n    if (!this.history.length) {\n      return;\n    }\n\n    this.setPeriod(this.history[0]);\n\n    // reset history\n    this.history = [];\n\n    this.props.onRestore?.(evt, chart);\n  };\n\n  handleDataZoom = (evt, chart) => {\n    const model = chart.getModel();\n    const {startValue, endValue} = model._payload.batch[0];\n\n    // if `rangeStart` and `rangeEnd` are null, then we are going back\n    if (startValue === null && endValue === null) {\n      const previousPeriod = this.history.pop();\n\n      if (!previousPeriod) {\n        return;\n      }\n\n      this.setPeriod(previousPeriod);\n    } else {\n      const start = moment.utc(startValue);\n\n      // Add a day so we go until the end of the day (e.g. next day at midnight)\n      const end = moment.utc(endValue);\n\n      this.setPeriod({period: null, start, end}, true);\n    }\n\n    this.props.onDataZoom?.(evt, chart);\n  };\n\n  /**\n   * Chart event when *any* rendering+animation finishes\n   *\n   * `this.zooming` acts as a callback function so that\n   * we can let the native zoom animation on the chart complete\n   * before we update URL state and re-render\n   */\n  handleChartFinished = (_props, chart) => {\n    if (typeof this.zooming === 'function') {\n      this.zooming();\n      this.zooming = null;\n    }\n\n    // This attempts to activate the area zoom toolbox feature\n    const zoom = chart._componentsViews?.find(c => c._features && c._features.dataZoom);\n    if (zoom && !zoom._features.dataZoom._isZoomActive) {\n      // Calling dispatchAction will re-trigger handleChartFinished\n      chart.dispatchAction({\n        type: 'takeGlobalCursor',\n        key: 'dataZoomSelect',\n        dataZoomSelectActive: true,\n      });\n    }\n\n    callIfFunction(this.props.onFinished);\n  };\n\n  render() {\n    const {\n      utc: _utc,\n      start: _start,\n      end: _end,\n      disabled,\n      children,\n      xAxisIndex,\n\n      router: _router,\n      onZoom: _onZoom,\n      onRestore: _onRestore,\n      onChartReady: _onChartReady,\n      onDataZoom: _onDataZoom,\n      onFinished: _onFinished,\n      showSlider,\n      chartZoomOptions,\n      ...props\n    } = this.props;\n\n    const utc = _utc ?? undefined;\n    const start = _start ? getUtcToLocalDateObject(_start) : undefined;\n    const end = _end ? getUtcToLocalDateObject(_end) : undefined;\n\n    if (disabled) {\n      return children({\n        utc,\n        start,\n        end,\n        ...props,\n      });\n    }\n    const renderProps = {\n      // Zooming only works when grouped by date\n      isGroupedByDate: true,\n      onChartReady: this.handleChartReady,\n      utc,\n      start,\n      end,\n      dataZoom: showSlider\n        ? [\n            ...DataZoomSlider({xAxisIndex, ...chartZoomOptions}),\n            ...DataZoomInside({\n              xAxisIndex,\n              ...(chartZoomOptions as InsideDataZoomComponentOption),\n            }),\n          ]\n        : DataZoomInside({\n            xAxisIndex,\n            ...(chartZoomOptions as InsideDataZoomComponentOption),\n          }),\n      showTimeInTooltip: true,\n      toolBox: ToolBox(\n        {},\n        {\n          dataZoom: {\n            title: {\n              zoom: '',\n              back: '',\n            },\n            iconStyle: {\n              borderWidth: 0,\n              color: 'transparent',\n              opacity: 0,\n            },\n          },\n        }\n      ),\n      onDataZoom: this.handleDataZoom,\n      onFinished: this.handleChartFinished,\n      onRestore: this.handleZoomRestore,\n      ...props,\n    };\n\n    return children(renderProps);\n  }\n}\n\nexport default ChartZoom;\n","import 'echarts/lib/component/dataZoomInside';\n\nimport type {InsideDataZoomComponentOption} from 'echarts';\n\nconst DEFAULT: InsideDataZoomComponentOption = {\n  type: 'inside',\n  // Mouse wheel can not trigger zoom\n  zoomOnMouseWheel: false,\n  // The translation (by mouse drag or touch drag) is available but zoom is not\n  zoomLock: true,\n  throttle: 50,\n};\n\nexport default function DataZoomInside(\n  props: InsideDataZoomComponentOption | InsideDataZoomComponentOption[]\n): InsideDataZoomComponentOption[] {\n  // `props` can be boolean, if so return default\n  if (!props || !Array.isArray(props)) {\n    const dataZoom = {\n      ...DEFAULT,\n      ...props,\n    };\n    return [dataZoom];\n  }\n\n  return props;\n}\n","import type {ToolboxComponentOption} from 'echarts';\n\nfunction getFeatures({\n  dataZoom,\n  ...features\n}: ToolboxComponentOption['feature'] = {}): ToolboxComponentOption['feature'] {\n  return {\n    ...(dataZoom\n      ? {\n          dataZoom: {\n            yAxisIndex: 'none',\n            title: {\n              zoom: 'zoom',\n              back: 'undo',\n            },\n            ...dataZoom,\n          },\n        }\n      : {}),\n    ...features,\n  };\n}\n\nexport default function ToolBox(\n  options: ToolboxComponentOption,\n  features: ToolboxComponentOption['feature']\n): ToolboxComponentOption {\n  return {\n    right: 0,\n    top: 0,\n    itemSize: 16,\n    // Stack the toolbox under the legend.\n    // so all series names are clickable.\n    z: -1,\n\n    feature: getFeatures(features),\n    ...options,\n  };\n}\n","import {EventsMetaType, MetaType} from 'sentry/utils/discover/eventView';\nimport {TransactionThresholdMetric} from 'sentry/views/performance/transactionSummary/transactionThresholdModal';\n\nimport GenericDiscoverQuery, {\n  DiscoverQueryProps,\n  GenericChildrenProps,\n  useGenericDiscoverQuery,\n} from './genericDiscoverQuery';\n\n/**\n * An individual row in a DiscoverQuery result\n */\nexport type TableDataRow = {\n  [key: string]: React.ReactText;\n  id: string;\n};\n\n/**\n * A DiscoverQuery result including rows and metadata.\n */\nexport type TableData = {\n  data: Array<TableDataRow>;\n  meta?: MetaType;\n};\n\n/**\n * A DiscoverQuery result including rows and metadata from the events endpoint.\n */\nexport type EventsTableData = {\n  data: Array<TableDataRow>;\n  meta?: EventsMetaType;\n};\n\nexport type TableDataWithTitle = TableData & {title: string};\n\nexport type DiscoverQueryPropsWithThresholds = DiscoverQueryProps & {\n  transactionName?: string;\n  transactionThreshold?: number;\n  transactionThresholdMetric?: TransactionThresholdMetric;\n};\n\nexport type DiscoverQueryComponentProps = DiscoverQueryPropsWithThresholds & {\n  children: (props: GenericChildrenProps<TableData>) => React.ReactNode;\n};\n\nfunction shouldRefetchData(\n  prevProps: DiscoverQueryPropsWithThresholds,\n  nextProps: DiscoverQueryPropsWithThresholds\n) {\n  return (\n    prevProps.transactionName !== nextProps.transactionName ||\n    prevProps.transactionThreshold !== nextProps.transactionThreshold ||\n    prevProps.transactionThresholdMetric !== nextProps.transactionThresholdMetric\n  );\n}\n\nfunction DiscoverQuery(props: DiscoverQueryComponentProps) {\n  const afterFetch = (data, _) => {\n    const {fields, ...otherMeta} = data.meta ?? {};\n    return {\n      ...data,\n      meta: {...fields, ...otherMeta},\n    };\n  };\n  return (\n    <GenericDiscoverQuery<TableData, DiscoverQueryPropsWithThresholds>\n      route=\"events\"\n      shouldRefetchData={shouldRefetchData}\n      afterFetch={afterFetch}\n      {...props}\n    />\n  );\n}\n\nexport function useDiscoverQuery(props: Omit<DiscoverQueryComponentProps, 'children'>) {\n  const afterFetch = (data, _) => {\n    const {fields, ...otherMeta} = data.meta ?? {};\n    return {\n      ...data,\n      meta: {...fields, ...otherMeta},\n    };\n  };\n\n  return useGenericDiscoverQuery<TableData, DiscoverQueryPropsWithThresholds>({\n    route: 'events',\n    shouldRefetchData,\n    afterFetch,\n    ...props,\n  });\n}\n\nexport default DiscoverQuery;\n","import 'echarts/lib/chart/scatter';\n\nimport type {ScatterSeriesOption} from 'echarts';\n\nimport theme from 'sentry/utils/theme';\n\nexport default function ScatterSeries(props: ScatterSeriesOption): ScatterSeriesOption {\n  return {\n    symbolSize: theme.charts.symbolSize,\n    ...props,\n    type: 'scatter',\n    emphasis: {\n      ...props.emphasis,\n      scale: true,\n    },\n  };\n}\n","import {useTheme} from '@emotion/react';\nimport {LineSeriesOption} from 'echarts';\nimport {YAXisOption} from 'echarts/types/dist/shared';\nimport max from 'lodash/max';\nimport min from 'lodash/min';\n\nimport {AreaChart, AreaChartProps} from 'sentry/components/charts/areaChart';\nimport {BarChart} from 'sentry/components/charts/barChart';\nimport BaseChart from 'sentry/components/charts/baseChart';\nimport ChartZoom from 'sentry/components/charts/chartZoom';\nimport {LineChart} from 'sentry/components/charts/lineChart';\nimport LineSeries from 'sentry/components/charts/series/lineSeries';\nimport ScatterSeries from 'sentry/components/charts/series/scatterSeries';\nimport {DateString} from 'sentry/types';\nimport {Series} from 'sentry/types/echarts';\nimport {\n  axisLabelFormatter,\n  getDurationUnit,\n  tooltipFormatter,\n} from 'sentry/utils/discover/charts';\nimport {aggregateOutputType} from 'sentry/utils/discover/fields';\nimport useRouter from 'sentry/utils/useRouter';\n\ntype Props = {\n  data: Series[];\n  end: DateString;\n  loading: boolean;\n  start: DateString;\n  statsPeriod: string | null | undefined;\n  utc: boolean;\n  chartColors?: string[];\n  definedAxisTicks?: number;\n  disableXAxis?: boolean;\n  grid?: AreaChartProps['grid'];\n  height?: number;\n  hideYAxisSplitLine?: boolean;\n  isBarChart?: boolean;\n  isLineChart?: boolean;\n  log?: boolean;\n  previousData?: Series[];\n  scatterPlot?: Series[];\n  showLegend?: boolean;\n  stacked?: boolean;\n  throughput?: {count: number; interval: string}[];\n};\n\nfunction computeMax(data: Series[]) {\n  const valuesDict = data.map(value => value.data.map(point => point.value));\n\n  return max(valuesDict.map(max)) as number;\n}\n\n// adapted from https://stackoverflow.com/questions/11397239/rounding-up-for-a-graph-maximum\nfunction computeAxisMax(data: Series[]) {\n  // assumes min is 0\n  let maxValue = 0;\n  if (data.length > 2) {\n    for (let i = 0; i < data.length; i++) {\n      maxValue += max(data[i].data.map(point => point.value)) as number;\n    }\n  } else {\n    maxValue = computeMax(data);\n  }\n\n  if (maxValue <= 1) {\n    return 1;\n  }\n\n  const power = Math.log10(maxValue);\n  const magnitude = min([max([10 ** (power - Math.floor(power)), 0]), 10]) as number;\n\n  let scale: number;\n  if (magnitude <= 2.5) {\n    scale = 0.2;\n  } else if (magnitude <= 5) {\n    scale = 0.5;\n  } else if (magnitude <= 7.5) {\n    scale = 1.0;\n  } else {\n    scale = 2.0;\n  }\n\n  const step = 10 ** Math.floor(power) * scale;\n  return Math.round(Math.ceil(maxValue / step) * step);\n}\n\nfunction Chart({\n  data,\n  previousData,\n  statsPeriod,\n  start,\n  end,\n  utc,\n  loading,\n  height,\n  grid,\n  disableXAxis,\n  definedAxisTicks,\n  chartColors,\n  isBarChart,\n  isLineChart,\n  stacked,\n  log,\n  hideYAxisSplitLine,\n  showLegend,\n  scatterPlot,\n  throughput,\n}: Props) {\n  const router = useRouter();\n  const theme = useTheme();\n\n  if (!data || data.length <= 0) {\n    return null;\n  }\n\n  const colors = chartColors ?? theme.charts.getColorPalette(4);\n\n  const durationOnly = data.every(\n    value => aggregateOutputType(value.seriesName) === 'duration'\n  );\n  const percentOnly = data.every(\n    value => aggregateOutputType(value.seriesName) === 'percentage'\n  );\n\n  let dataMax = durationOnly\n    ? computeAxisMax([...data, ...(scatterPlot ?? [])])\n    : percentOnly\n    ? computeMax(data)\n    : undefined;\n  // Fix an issue where max == 1 for duration charts would look funky cause we round\n  if (dataMax === 1 && durationOnly) {\n    dataMax += 1;\n  }\n\n  const durationUnit = getDurationUnit(data);\n\n  let transformedThroughput: LineSeriesOption[] | undefined = undefined;\n  const additionalAxis: YAXisOption[] = [];\n\n  if (throughput && throughput.length > 1) {\n    transformedThroughput = [\n      LineSeries({\n        name: 'Throughput',\n        data: throughput.map(({interval, count}) => [interval, count]),\n        yAxisIndex: 1,\n        lineStyle: {type: 'dashed', width: 1, opacity: 0.5},\n        animation: false,\n        animationThreshold: 1,\n        animationDuration: 0,\n      }),\n    ];\n    additionalAxis.push({\n      minInterval: durationUnit,\n      splitNumber: definedAxisTicks,\n      max: dataMax,\n      type: 'value',\n      axisLabel: {\n        color: theme.chartLabel,\n        formatter(value: number) {\n          return axisLabelFormatter(value, 'number', true);\n        },\n      },\n      splitLine: hideYAxisSplitLine ? {show: false} : undefined,\n    });\n  }\n\n  const yAxes = [\n    {\n      minInterval: durationUnit,\n      splitNumber: definedAxisTicks,\n      max: dataMax,\n      type: log ? 'log' : 'value',\n      axisLabel: {\n        color: theme.chartLabel,\n        formatter(value: number) {\n          return axisLabelFormatter(\n            value,\n            aggregateOutputType(data[0].seriesName),\n            undefined,\n            durationUnit\n          );\n        },\n      },\n      splitLine: hideYAxisSplitLine ? {show: false} : undefined,\n    },\n    ...additionalAxis,\n  ];\n\n  const areaChartProps = {\n    seriesOptions: {\n      showSymbol: false,\n    },\n    grid,\n    yAxes,\n    utc,\n    legend: showLegend\n      ? {\n          top: 0,\n          right: 10,\n        }\n      : undefined,\n    isGroupedByDate: true,\n    showTimeInTooltip: true,\n    colors,\n    tooltip: {\n      trigger: 'axis',\n      axisPointer: {\n        type: 'cross',\n        label: {show: false},\n      },\n      valueFormatter: (value, seriesName) => {\n        return tooltipFormatter(\n          value,\n          aggregateOutputType(data && data.length ? data[0].seriesName : seriesName)\n        );\n      },\n      nameFormatter(value: string) {\n        return value === 'epm()' ? 'tpm()' : value;\n      },\n    },\n  } as Omit<AreaChartProps, 'series'>;\n\n  if (loading) {\n    if (isLineChart) {\n      return <LineChart height={height} series={[]} {...areaChartProps} />;\n    }\n    if (isBarChart) {\n      return <BarChart height={height} series={[]} {...areaChartProps} />;\n    }\n    return <AreaChart height={height} series={[]} {...areaChartProps} />;\n  }\n  const series = data.map((values, _) => ({\n    ...values,\n    yAxisIndex: 0,\n    xAxisIndex: 0,\n  }));\n\n  const xAxis = disableXAxis\n    ? {\n        show: false,\n        axisLabel: {show: true, margin: 0},\n        axisLine: {show: false},\n      }\n    : undefined;\n\n  return (\n    <ChartZoom router={router} period={statsPeriod} start={start} end={end} utc={utc}>\n      {zoomRenderProps => {\n        if (isLineChart) {\n          return (\n            <BaseChart\n              {...zoomRenderProps}\n              height={height}\n              previousPeriod={previousData}\n              additionalSeries={transformedThroughput}\n              xAxis={xAxis}\n              yAxes={areaChartProps.yAxes}\n              tooltip={areaChartProps.tooltip}\n              colors={colors}\n              grid={grid}\n              legend={showLegend ? {top: 0, right: 0} : undefined}\n              series={[\n                ...series.map(({seriesName, data: seriesData, ...options}) =>\n                  LineSeries({\n                    ...options,\n                    name: seriesName,\n                    data: seriesData?.map(({value, name}) => [name, value]),\n                    animation: false,\n                    animationThreshold: 1,\n                    animationDuration: 0,\n                  })\n                ),\n                ...(scatterPlot ?? []).map(({seriesName, data: seriesData, ...options}) =>\n                  ScatterSeries({\n                    ...options,\n                    name: seriesName,\n                    data: seriesData?.map(({value, name}) => [name, value]),\n                    animation: false,\n                  })\n                ),\n              ]}\n            />\n          );\n        }\n\n        if (isBarChart) {\n          return (\n            <BarChart\n              height={height}\n              series={series}\n              xAxis={xAxis}\n              additionalSeries={transformedThroughput}\n              yAxes={areaChartProps.yAxes}\n              tooltip={areaChartProps.tooltip}\n              colors={colors}\n              grid={grid}\n              legend={showLegend ? {top: 0, right: 0} : undefined}\n            />\n          );\n        }\n\n        return (\n          <AreaChart\n            height={height}\n            {...zoomRenderProps}\n            series={series}\n            previousPeriod={previousData}\n            additionalSeries={transformedThroughput}\n            xAxis={xAxis}\n            stacked={stacked}\n            {...areaChartProps}\n          />\n        );\n      }}\n    </ChartZoom>\n  );\n}\n\nexport default Chart;\n","import moment from 'moment';\n\nimport {DateTimeObject} from 'sentry/components/charts/utils';\nimport {DateString} from 'sentry/types';\nimport {getPeriodAgo, getUtcDateString, parsePeriodToHours} from 'sentry/utils/dates';\n\nfunction midTimestamp(start: DateString, end: DateString): string {\n  const diff = moment(end).diff(moment(start));\n  const middle = moment(start).add(diff / 2);\n  return getUtcDateString(middle);\n}\n\nexport function getMiddleTimestamp({\n  start,\n  end,\n  statsPeriod,\n}: {\n  end?: string;\n  start?: string;\n  statsPeriod?: string;\n}) {\n  if (statsPeriod) {\n    const rangeStart = getPeriodAgo('hours', parsePeriodToHours(statsPeriod)).toDate();\n    const rangeEnd = new Date();\n    return midTimestamp(rangeStart, rangeEnd);\n  }\n\n  if (!start || !end) {\n    throw new Error('start and end required');\n  }\n\n  return midTimestamp(start, end);\n}\n\nexport const PERIOD_REGEX = /^(\\d+)([h,d])$/;\nexport const DATE_FORMAT = 'YYYY-MM-DD HH:mm:ss';\n\nexport const datetimeToClickhouseFilterTimestamps = (datetime?: DateTimeObject) => {\n  if (!datetime) {\n    return {};\n  }\n  const [_, num, unit] = datetime.period?.match(PERIOD_REGEX) ?? [];\n  const start_timestamp =\n    (datetime.start && moment(datetime.start).format(DATE_FORMAT)) ??\n    (num &&\n      unit &&\n      moment()\n        .subtract(num, unit as 'h' | 'd')\n        .format(DATE_FORMAT));\n\n  const end_timestamp = datetime.end && moment(datetime.end).format(DATE_FORMAT);\n  return {start_timestamp, end_timestamp};\n};\n\nexport function getDateFilters(pageFilter) {\n  const [_, num, unit] = pageFilter.selection.datetime.period?.match(PERIOD_REGEX) ?? [];\n  const startTime =\n    num && unit\n      ? moment().subtract(num, unit as 'h' | 'd')\n      : moment(pageFilter.selection.datetime.start);\n  const endTime = moment(pageFilter.selection.datetime.end ?? undefined);\n  return {startTime, endTime};\n}\n","import moment from 'moment';\n\nimport {Series, SeriesDataUnit} from 'sentry/types/echarts';\n\nexport function zeroFillSeries(\n  series: Series,\n  interval: moment.Duration,\n  startTime?: moment.Moment,\n  endTime?: moment.Moment,\n  zerofillValue?: any\n): Series {\n  if (!series?.data?.length) {\n    return series;\n  }\n  if (!zerofillValue) {\n    zerofillValue = 0;\n  }\n\n  const firstDatum = series.data[0];\n  const lastDatum = series.data[series.data.length - 1];\n  const dateFormat = moment(firstDatum.name).creationData().format?.toString();\n\n  if (!dateFormat) {\n    return series;\n  }\n\n  const newData: SeriesDataUnit[] = [];\n\n  const startTimeNearestInterval = startTime && roundUpToNearest12HourInterval(startTime);\n  const endTimeNearestInterval = endTime && roundDownToNearest12HourInterval(endTime);\n\n  const seriesData = [\n    ...(startTimeNearestInterval &&\n    startTimeNearestInterval.diff(moment(firstDatum.name)) < 0\n      ? [{value: zerofillValue, name: startTimeNearestInterval.format(dateFormat)}]\n      : []),\n    ...series.data,\n    ...(endTimeNearestInterval && endTimeNearestInterval.diff(moment(lastDatum.name)) > 0\n      ? [{value: zerofillValue, name: endTimeNearestInterval.format(dateFormat)}]\n      : []),\n  ];\n\n  let currentDatum, nextDatum, lastSeenDate, nextDate, diff;\n  for (let index = 0; index < seriesData.length - 1; index++) {\n    // Push the first datapoint\n    if (index === 0) {\n      newData.push({\n        ...seriesData[index],\n        name: moment(seriesData[index].name).format(dateFormat),\n      });\n    }\n\n    currentDatum = seriesData[index];\n    nextDatum = seriesData[index + 1];\n\n    lastSeenDate = moment(currentDatum.name);\n    nextDate = moment(nextDatum.name);\n\n    diff = moment.duration(nextDate.diff(lastSeenDate));\n\n    while (diff.asMilliseconds() > interval.asMilliseconds()) {\n      // The gap between the two datapoints is more than the intended interval!\n      // We need to fill 0s\n      lastSeenDate.add(interval);\n\n      newData.push({\n        value: zerofillValue,\n        name: moment(lastSeenDate).format(dateFormat),\n      });\n\n      diff = moment.duration(moment(nextDatum.name).diff(lastSeenDate));\n    }\n\n    // Push the next datapoint\n    newData.push({\n      ...nextDatum,\n      name: moment(nextDatum.name).format(dateFormat),\n    });\n  }\n\n  return {\n    ...series,\n    data: newData,\n  };\n}\n\nfunction roundUpToNearest12HourInterval(time: moment.Moment) {\n  return roundDownToNearest12HourInterval(time.clone().add(12, 'hour').subtract(1, 'ms'));\n}\n\nfunction roundDownToNearest12HourInterval(time: moment.Moment) {\n  const hour = time.hour();\n  const nearestDay = time.clone().startOf('day');\n  if (hour < 12) {\n    return nearestDay;\n  }\n  return nearestDay.add(12, 'hour');\n}\n"],"names":["AreaChart","_ref","series","stacked","colors","props","_jsx","BaseChart","map","_ref2","i","seriesName","data","otherSeriesProps","arguments","length","undefined","LineSeries","AreaSeries","stack","name","_ref3","value","lineStyle","color","opacity","width","areaStyle","animation","animationThreshold","animationDuration","displayName","DEFAULT","realtime","showDetail","left","right","bottom","DataZoomSlider","Array","isArray","getDate","date","moment","format","ChartZoom","Component","constructor","_this","super","this","_defineProperty","currentPeriod","period","start","end","saveHistory","router","onZoom","usePageDate","startFormatted","endFormatted","history","push","zooming","newQuery","location","query","pageStart","getUtcDateString","pageEnd","pageStatsPeriod","qs","pathname","updateDateTime","getUtcToLocalDateObject","skipDesyncUpdate","saveCurrentPeriod","chart","onChartReady","evt","setPeriod","onRestore","model","getModel","startValue","endValue","_payload","batch","previousPeriod","pop","onDataZoom","_props","zoom","_componentsViews","find","c","_features","dataZoom","_isZoomActive","dispatchAction","type","key","dataZoomSelectActive","callIfFunction","onFinished","componentDidUpdate","disabled","render","utc","_utc","_start","_end","children","xAxisIndex","_router","_onZoom","_onRestore","_onChartReady","_onDataZoom","_onFinished","showSlider","chartZoomOptions","isGroupedByDate","handleChartReady","DataZoomInside","showTimeInTooltip","toolBox","ToolBox","title","back","iconStyle","borderWidth","handleDataZoom","handleChartFinished","handleZoomRestore","zoomOnMouseWheel","zoomLock","throttle","getFeatures","features","yAxisIndex","options","top","itemSize","z","feature","shouldRefetchData","prevProps","nextProps","transactionName","transactionThreshold","transactionThresholdMetric","DiscoverQuery","GenericDiscoverQuery","route","afterFetch","_","fields","otherMeta","meta","useDiscoverQuery","useGenericDiscoverQuery","ScatterSeries","symbolSize","theme","emphasis","scale","computeMax","valuesDict","point","max","Chart","previousData","statsPeriod","loading","height","grid","disableXAxis","definedAxisTicks","chartColors","isBarChart","isLineChart","log","hideYAxisSplitLine","showLegend","scatterPlot","throughput","useRouter","useTheme","charts","getColorPalette","durationOnly","every","aggregateOutputType","percentOnly","dataMax","maxValue","power","Math","log10","magnitude","min","floor","step","round","ceil","computeAxisMax","durationUnit","getDurationUnit","transformedThroughput","additionalAxis","interval","count","minInterval","splitNumber","axisLabel","chartLabel","formatter","axisLabelFormatter","splitLine","show","yAxes","areaChartProps","seriesOptions","showSymbol","legend","tooltip","trigger","axisPointer","label","valueFormatter","tooltipFormatter","nameFormatter","LineChart","BarChart","values","xAxis","margin","axisLine","zoomRenderProps","additionalSeries","seriesData","_ref4","_ref5","_ref6","midTimestamp","diff","middle","add","getMiddleTimestamp","getPeriodAgo","parsePeriodToHours","toDate","Date","Error","PERIOD_REGEX","DATE_FORMAT","datetimeToClickhouseFilterTimestamps","datetime","num","unit","match","start_timestamp","subtract","end_timestamp","getDateFilters","pageFilter","selection","startTime","endTime","zeroFillSeries","zerofillValue","firstDatum","lastDatum","dateFormat","creationData","toString","newData","startTimeNearestInterval","roundDownToNearest12HourInterval","clone","endTimeNearestInterval","currentDatum","nextDatum","lastSeenDate","nextDate","index","asMilliseconds","time","hour","nearestDay","startOf"],"sourceRoot":""}