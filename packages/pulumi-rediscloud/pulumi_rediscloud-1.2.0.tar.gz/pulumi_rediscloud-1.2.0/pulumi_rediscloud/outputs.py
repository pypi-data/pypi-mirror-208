# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ActiveActiveSubscriptionCreationPlan',
    'ActiveActiveSubscriptionCreationPlanRegion',
    'ActiveActiveSubscriptionDatabaseGlobalAlert',
    'ActiveActiveSubscriptionDatabaseOverrideRegion',
    'ActiveActiveSubscriptionDatabaseOverrideRegionOverrideGlobalAlert',
    'ActiveActiveSubscriptionRegionsRegion',
    'ActiveActiveSubscriptionRegionsRegionDatabase',
    'SubscriptionAllowlist',
    'SubscriptionCloudProvider',
    'SubscriptionCloudProviderRegion',
    'SubscriptionCloudProviderRegionNetwork',
    'SubscriptionCreationPlan',
    'SubscriptionDatabaseAlert',
    'SubscriptionDatabaseModule',
    'GetDataPersistenceDataPersistenceResult',
    'GetDatabaseAlertResult',
    'GetDatabaseModuleResult',
    'GetDatabaseModulesModuleResult',
    'GetRegionsRegionResult',
    'GetSubscriptionCloudProviderResult',
    'GetSubscriptionCloudProviderRegionResult',
    'GetSubscriptionCloudProviderRegionNetworkResult',
    'GetSubscriptionPeeringsPeeringResult',
]

@pulumi.output_type
class ActiveActiveSubscriptionCreationPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryLimitInGb":
            suggest = "memory_limit_in_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveActiveSubscriptionCreationPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveActiveSubscriptionCreationPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveActiveSubscriptionCreationPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_limit_in_gb: float,
                 quantity: int,
                 regions: Sequence['outputs.ActiveActiveSubscriptionCreationPlanRegion']):
        """
        :param float memory_limit_in_gb: Maximum memory usage that will be used for your largest planned database, including replication and other overhead
        :param int quantity: The planned number of databases in the subscription.
        """
        pulumi.set(__self__, "memory_limit_in_gb", memory_limit_in_gb)
        pulumi.set(__self__, "quantity", quantity)
        pulumi.set(__self__, "regions", regions)

    @property
    @pulumi.getter(name="memoryLimitInGb")
    def memory_limit_in_gb(self) -> float:
        """
        Maximum memory usage that will be used for your largest planned database, including replication and other overhead
        """
        return pulumi.get(self, "memory_limit_in_gb")

    @property
    @pulumi.getter
    def quantity(self) -> int:
        """
        The planned number of databases in the subscription.
        """
        return pulumi.get(self, "quantity")

    @property
    @pulumi.getter
    def regions(self) -> Sequence['outputs.ActiveActiveSubscriptionCreationPlanRegion']:
        return pulumi.get(self, "regions")


@pulumi.output_type
class ActiveActiveSubscriptionCreationPlanRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkingDeploymentCidr":
            suggest = "networking_deployment_cidr"
        elif key == "readOperationsPerSecond":
            suggest = "read_operations_per_second"
        elif key == "writeOperationsPerSecond":
            suggest = "write_operations_per_second"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveActiveSubscriptionCreationPlanRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveActiveSubscriptionCreationPlanRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveActiveSubscriptionCreationPlanRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 networking_deployment_cidr: str,
                 read_operations_per_second: int,
                 region: str,
                 write_operations_per_second: int):
        """
        :param str networking_deployment_cidr: Deployment CIDR mask. The total number of bits must be 24 (x.x.x.x/24)
        :param int read_operations_per_second: Throughput measurement for an active-active subscription
        :param str region: Deployment region as defined by cloud provider
        :param int write_operations_per_second: Throughput measurement for an active-active subscription
        """
        pulumi.set(__self__, "networking_deployment_cidr", networking_deployment_cidr)
        pulumi.set(__self__, "read_operations_per_second", read_operations_per_second)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "write_operations_per_second", write_operations_per_second)

    @property
    @pulumi.getter(name="networkingDeploymentCidr")
    def networking_deployment_cidr(self) -> str:
        """
        Deployment CIDR mask. The total number of bits must be 24 (x.x.x.x/24)
        """
        return pulumi.get(self, "networking_deployment_cidr")

    @property
    @pulumi.getter(name="readOperationsPerSecond")
    def read_operations_per_second(self) -> int:
        """
        Throughput measurement for an active-active subscription
        """
        return pulumi.get(self, "read_operations_per_second")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Deployment region as defined by cloud provider
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="writeOperationsPerSecond")
    def write_operations_per_second(self) -> int:
        """
        Throughput measurement for an active-active subscription
        """
        return pulumi.get(self, "write_operations_per_second")


@pulumi.output_type
class ActiveActiveSubscriptionDatabaseGlobalAlert(dict):
    def __init__(__self__, *,
                 name: str,
                 value: int):
        """
        :param str name: A meaningful name to identify the database
        :param int value: Alert value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A meaningful name to identify the database
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Alert value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ActiveActiveSubscriptionDatabaseOverrideRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overrideGlobalAlerts":
            suggest = "override_global_alerts"
        elif key == "overrideGlobalDataPersistence":
            suggest = "override_global_data_persistence"
        elif key == "overrideGlobalPassword":
            suggest = "override_global_password"
        elif key == "overrideGlobalSourceIps":
            suggest = "override_global_source_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveActiveSubscriptionDatabaseOverrideRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveActiveSubscriptionDatabaseOverrideRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveActiveSubscriptionDatabaseOverrideRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 override_global_alerts: Optional[Sequence['outputs.ActiveActiveSubscriptionDatabaseOverrideRegionOverrideGlobalAlert']] = None,
                 override_global_data_persistence: Optional[str] = None,
                 override_global_password: Optional[str] = None,
                 override_global_source_ips: Optional[Sequence[str]] = None):
        """
        :param str name: Region name.
        :param Sequence['ActiveActiveSubscriptionDatabaseOverrideRegionOverrideGlobalAlertArgs'] override_global_alerts: A block defining Redis regional instance of an Active-Active database alert, documented below, can be specified multiple times
        :param str override_global_data_persistence: Regional instance of an Active-Active database data persistence rate (in persistent storage)
        :param str override_global_password: If specified, this regional instance of an Active-Active database password will be used to access the database
        :param Sequence[str] override_global_source_ips: List of regional instance of an Active-Active database source IP addresses or subnet masks. If specified, Redis clients will be able to connect to this database only from within the specified source IP addresses ranges (example: ['192.168.10.0/32', '192.168.12.0/24'] )
        """
        pulumi.set(__self__, "name", name)
        if override_global_alerts is not None:
            pulumi.set(__self__, "override_global_alerts", override_global_alerts)
        if override_global_data_persistence is not None:
            pulumi.set(__self__, "override_global_data_persistence", override_global_data_persistence)
        if override_global_password is not None:
            pulumi.set(__self__, "override_global_password", override_global_password)
        if override_global_source_ips is not None:
            pulumi.set(__self__, "override_global_source_ips", override_global_source_ips)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Region name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideGlobalAlerts")
    def override_global_alerts(self) -> Optional[Sequence['outputs.ActiveActiveSubscriptionDatabaseOverrideRegionOverrideGlobalAlert']]:
        """
        A block defining Redis regional instance of an Active-Active database alert, documented below, can be specified multiple times
        """
        return pulumi.get(self, "override_global_alerts")

    @property
    @pulumi.getter(name="overrideGlobalDataPersistence")
    def override_global_data_persistence(self) -> Optional[str]:
        """
        Regional instance of an Active-Active database data persistence rate (in persistent storage)
        """
        return pulumi.get(self, "override_global_data_persistence")

    @property
    @pulumi.getter(name="overrideGlobalPassword")
    def override_global_password(self) -> Optional[str]:
        """
        If specified, this regional instance of an Active-Active database password will be used to access the database
        """
        return pulumi.get(self, "override_global_password")

    @property
    @pulumi.getter(name="overrideGlobalSourceIps")
    def override_global_source_ips(self) -> Optional[Sequence[str]]:
        """
        List of regional instance of an Active-Active database source IP addresses or subnet masks. If specified, Redis clients will be able to connect to this database only from within the specified source IP addresses ranges (example: ['192.168.10.0/32', '192.168.12.0/24'] )
        """
        return pulumi.get(self, "override_global_source_ips")


@pulumi.output_type
class ActiveActiveSubscriptionDatabaseOverrideRegionOverrideGlobalAlert(dict):
    def __init__(__self__, *,
                 name: str,
                 value: int):
        """
        :param str name: Alert name
        :param int value: Alert value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Alert name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Alert value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ActiveActiveSubscriptionRegionsRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkingDeploymentCidr":
            suggest = "networking_deployment_cidr"
        elif key == "recreateRegion":
            suggest = "recreate_region"
        elif key == "regionId":
            suggest = "region_id"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveActiveSubscriptionRegionsRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveActiveSubscriptionRegionsRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveActiveSubscriptionRegionsRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 databases: Sequence['outputs.ActiveActiveSubscriptionRegionsRegionDatabase'],
                 networking_deployment_cidr: str,
                 region: str,
                 recreate_region: Optional[bool] = None,
                 region_id: Optional[int] = None,
                 vpc_id: Optional[str] = None):
        """
        :param Sequence['ActiveActiveSubscriptionRegionsRegionDatabaseArgs'] databases: A block defining the write and read operations in the region, per database, documented below
        :param str networking_deployment_cidr: Deployment CIDR mask. The total number of bits must be 24 (x.x.x.x/24)
        :param str region: Region name
        :param bool recreate_region: Protection flag, needs to be set if a region has to be re-created. A region will need to be re-created in the case of a change on the `networking_deployment_cidr` field. During re-create, the region will be deleted (so the `delete_regions` flag also needs to be set) and then created again. Default: 'false'
        :param int region_id: The ID of the region, as created by the API
        :param str vpc_id: Identifier of the VPC to be peered, set by the API
        """
        pulumi.set(__self__, "databases", databases)
        pulumi.set(__self__, "networking_deployment_cidr", networking_deployment_cidr)
        pulumi.set(__self__, "region", region)
        if recreate_region is not None:
            pulumi.set(__self__, "recreate_region", recreate_region)
        if region_id is not None:
            pulumi.set(__self__, "region_id", region_id)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter
    def databases(self) -> Sequence['outputs.ActiveActiveSubscriptionRegionsRegionDatabase']:
        """
        A block defining the write and read operations in the region, per database, documented below
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter(name="networkingDeploymentCidr")
    def networking_deployment_cidr(self) -> str:
        """
        Deployment CIDR mask. The total number of bits must be 24 (x.x.x.x/24)
        """
        return pulumi.get(self, "networking_deployment_cidr")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region name
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="recreateRegion")
    def recreate_region(self) -> Optional[bool]:
        """
        Protection flag, needs to be set if a region has to be re-created. A region will need to be re-created in the case of a change on the `networking_deployment_cidr` field. During re-create, the region will be deleted (so the `delete_regions` flag also needs to be set) and then created again. Default: 'false'
        """
        return pulumi.get(self, "recreate_region")

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> Optional[int]:
        """
        The ID of the region, as created by the API
        """
        return pulumi.get(self, "region_id")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        Identifier of the VPC to be peered, set by the API
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class ActiveActiveSubscriptionRegionsRegionDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseId":
            suggest = "database_id"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "localReadOperationsPerSecond":
            suggest = "local_read_operations_per_second"
        elif key == "localWriteOperationsPerSecond":
            suggest = "local_write_operations_per_second"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveActiveSubscriptionRegionsRegionDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveActiveSubscriptionRegionsRegionDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveActiveSubscriptionRegionsRegionDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_id: int,
                 database_name: str,
                 local_read_operations_per_second: int,
                 local_write_operations_per_second: int):
        """
        :param int database_id: Database ID belonging to the subscription
        :param str database_name: Database name belonging to the subscription
        :param int local_read_operations_per_second: Local read operations per second for this active-active region
        :param int local_write_operations_per_second: Local write operations per second for this active-active region
        """
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "local_read_operations_per_second", local_read_operations_per_second)
        pulumi.set(__self__, "local_write_operations_per_second", local_write_operations_per_second)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> int:
        """
        Database ID belonging to the subscription
        """
        return pulumi.get(self, "database_id")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database name belonging to the subscription
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="localReadOperationsPerSecond")
    def local_read_operations_per_second(self) -> int:
        """
        Local read operations per second for this active-active region
        """
        return pulumi.get(self, "local_read_operations_per_second")

    @property
    @pulumi.getter(name="localWriteOperationsPerSecond")
    def local_write_operations_per_second(self) -> int:
        """
        Local write operations per second for this active-active region
        """
        return pulumi.get(self, "local_write_operations_per_second")


@pulumi.output_type
class SubscriptionAllowlist(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupIds":
            suggest = "security_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionAllowlist. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionAllowlist.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionAllowlist.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_ids: Sequence[str],
                 cidrs: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] security_group_ids: Set of security groups that are allowed to access the databases associated with this subscription
        :param Sequence[str] cidrs: Set of CIDR ranges that are allowed to access the databases associated with this subscription
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        if cidrs is not None:
            pulumi.set(__self__, "cidrs", cidrs)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        """
        Set of security groups that are allowed to access the databases associated with this subscription
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter
    def cidrs(self) -> Optional[Sequence[str]]:
        """
        Set of CIDR ranges that are allowed to access the databases associated with this subscription
        """
        return pulumi.get(self, "cidrs")


@pulumi.output_type
class SubscriptionCloudProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudAccountId":
            suggest = "cloud_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionCloudProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionCloudProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionCloudProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regions: Sequence['outputs.SubscriptionCloudProviderRegion'],
                 cloud_account_id: Optional[str] = None,
                 provider: Optional[str] = None):
        """
        :param Sequence['SubscriptionCloudProviderRegionArgs'] regions: A region object, documented below
        :param str cloud_account_id: Cloud account identifier. Default: Redis Labs internal cloud account
               (using Cloud Account ID = 1 implies using Redis Labs internal cloud account). Note that a GCP subscription can be created
               only with Redis Labs internal cloud account
        :param str provider: The cloud provider to use with the subscription, (either `AWS` or `GCP`). Default: ‘AWS’
        """
        pulumi.set(__self__, "regions", regions)
        if cloud_account_id is not None:
            pulumi.set(__self__, "cloud_account_id", cloud_account_id)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)

    @property
    @pulumi.getter
    def regions(self) -> Sequence['outputs.SubscriptionCloudProviderRegion']:
        """
        A region object, documented below
        """
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="cloudAccountId")
    def cloud_account_id(self) -> Optional[str]:
        """
        Cloud account identifier. Default: Redis Labs internal cloud account
        (using Cloud Account ID = 1 implies using Redis Labs internal cloud account). Note that a GCP subscription can be created
        only with Redis Labs internal cloud account
        """
        return pulumi.get(self, "cloud_account_id")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        The cloud provider to use with the subscription, (either `AWS` or `GCP`). Default: ‘AWS’
        """
        return pulumi.get(self, "provider")


@pulumi.output_type
class SubscriptionCloudProviderRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkingDeploymentCidr":
            suggest = "networking_deployment_cidr"
        elif key == "preferredAvailabilityZones":
            suggest = "preferred_availability_zones"
        elif key == "multipleAvailabilityZones":
            suggest = "multiple_availability_zones"
        elif key == "networkingVpcId":
            suggest = "networking_vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionCloudProviderRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionCloudProviderRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionCloudProviderRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 networking_deployment_cidr: str,
                 preferred_availability_zones: Sequence[str],
                 region: str,
                 multiple_availability_zones: Optional[bool] = None,
                 networking_vpc_id: Optional[str] = None,
                 networks: Optional[Sequence['outputs.SubscriptionCloudProviderRegionNetwork']] = None):
        """
        :param str networking_deployment_cidr: Deployment CIDR mask. The total number of bits must be 24 (x.x.x.x/24)
        :param Sequence[str] preferred_availability_zones: Availability zones deployment preferences (for the selected provider & region). If multiple_availability_zones is set to 'true', select three availability zones from the list. If you don't want to specify preferred avaialbility zones, set this attribute to an empty list ('[]').
        :param str region: Deployment region as defined by cloud provider
        :param bool multiple_availability_zones: Support deployment on multiple availability zones within the selected region. Default: ‘false’
        :param str networking_vpc_id: Either an existing VPC Id (already exists in the specific region) or create a new VPC
               (if no VPC is specified). VPC Identifier must be in a valid format (for example: ‘vpc-0125be68a4986384ad’) and existing
               within the hosting account.
        :param Sequence['SubscriptionCloudProviderRegionNetworkArgs'] networks: List of generated network configuration
        """
        pulumi.set(__self__, "networking_deployment_cidr", networking_deployment_cidr)
        pulumi.set(__self__, "preferred_availability_zones", preferred_availability_zones)
        pulumi.set(__self__, "region", region)
        if multiple_availability_zones is not None:
            pulumi.set(__self__, "multiple_availability_zones", multiple_availability_zones)
        if networking_vpc_id is not None:
            pulumi.set(__self__, "networking_vpc_id", networking_vpc_id)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter(name="networkingDeploymentCidr")
    def networking_deployment_cidr(self) -> str:
        """
        Deployment CIDR mask. The total number of bits must be 24 (x.x.x.x/24)
        """
        return pulumi.get(self, "networking_deployment_cidr")

    @property
    @pulumi.getter(name="preferredAvailabilityZones")
    def preferred_availability_zones(self) -> Sequence[str]:
        """
        Availability zones deployment preferences (for the selected provider & region). If multiple_availability_zones is set to 'true', select three availability zones from the list. If you don't want to specify preferred avaialbility zones, set this attribute to an empty list ('[]').
        """
        return pulumi.get(self, "preferred_availability_zones")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Deployment region as defined by cloud provider
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="multipleAvailabilityZones")
    def multiple_availability_zones(self) -> Optional[bool]:
        """
        Support deployment on multiple availability zones within the selected region. Default: ‘false’
        """
        return pulumi.get(self, "multiple_availability_zones")

    @property
    @pulumi.getter(name="networkingVpcId")
    def networking_vpc_id(self) -> Optional[str]:
        """
        Either an existing VPC Id (already exists in the specific region) or create a new VPC
        (if no VPC is specified). VPC Identifier must be in a valid format (for example: ‘vpc-0125be68a4986384ad’) and existing
        within the hosting account.
        """
        return pulumi.get(self, "networking_vpc_id")

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence['outputs.SubscriptionCloudProviderRegionNetwork']]:
        """
        List of generated network configuration
        """
        return pulumi.get(self, "networks")


@pulumi.output_type
class SubscriptionCloudProviderRegionNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkingDeploymentCidr":
            suggest = "networking_deployment_cidr"
        elif key == "networkingSubnetId":
            suggest = "networking_subnet_id"
        elif key == "networkingVpcId":
            suggest = "networking_vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionCloudProviderRegionNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionCloudProviderRegionNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionCloudProviderRegionNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 networking_deployment_cidr: Optional[str] = None,
                 networking_subnet_id: Optional[str] = None,
                 networking_vpc_id: Optional[str] = None):
        """
        :param str networking_deployment_cidr: Deployment CIDR mask. The total number of bits must be 24 (x.x.x.x/24)
        :param str networking_subnet_id: The subnet that the subscription deploys into
        :param str networking_vpc_id: Either an existing VPC Id (already exists in the specific region) or create a new VPC
               (if no VPC is specified). VPC Identifier must be in a valid format (for example: ‘vpc-0125be68a4986384ad’) and existing
               within the hosting account.
        """
        if networking_deployment_cidr is not None:
            pulumi.set(__self__, "networking_deployment_cidr", networking_deployment_cidr)
        if networking_subnet_id is not None:
            pulumi.set(__self__, "networking_subnet_id", networking_subnet_id)
        if networking_vpc_id is not None:
            pulumi.set(__self__, "networking_vpc_id", networking_vpc_id)

    @property
    @pulumi.getter(name="networkingDeploymentCidr")
    def networking_deployment_cidr(self) -> Optional[str]:
        """
        Deployment CIDR mask. The total number of bits must be 24 (x.x.x.x/24)
        """
        return pulumi.get(self, "networking_deployment_cidr")

    @property
    @pulumi.getter(name="networkingSubnetId")
    def networking_subnet_id(self) -> Optional[str]:
        """
        The subnet that the subscription deploys into
        """
        return pulumi.get(self, "networking_subnet_id")

    @property
    @pulumi.getter(name="networkingVpcId")
    def networking_vpc_id(self) -> Optional[str]:
        """
        Either an existing VPC Id (already exists in the specific region) or create a new VPC
        (if no VPC is specified). VPC Identifier must be in a valid format (for example: ‘vpc-0125be68a4986384ad’) and existing
        within the hosting account.
        """
        return pulumi.get(self, "networking_vpc_id")


@pulumi.output_type
class SubscriptionCreationPlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryLimitInGb":
            suggest = "memory_limit_in_gb"
        elif key == "throughputMeasurementBy":
            suggest = "throughput_measurement_by"
        elif key == "throughputMeasurementValue":
            suggest = "throughput_measurement_value"
        elif key == "averageItemSizeInBytes":
            suggest = "average_item_size_in_bytes"
        elif key == "supportOssClusterApi":
            suggest = "support_oss_cluster_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionCreationPlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionCreationPlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionCreationPlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_limit_in_gb: float,
                 modules: Sequence[str],
                 quantity: int,
                 replication: bool,
                 throughput_measurement_by: str,
                 throughput_measurement_value: int,
                 average_item_size_in_bytes: Optional[int] = None,
                 support_oss_cluster_api: Optional[bool] = None):
        """
        :param float memory_limit_in_gb: Maximum memory usage that will be used for your largest planned database.
        :param Sequence[str] modules: a list of modules that will be used by the databases in this subscription. Not currently compatible with ‘ram-and-flash’ memory storage.
               Example: `modules = ["RedisJSON", RedisBloom"]`
        :param int quantity: The planned number of databases in the subscription
        :param bool replication: Databases replication. Set to `true` if any of your databases will use replication
        :param str throughput_measurement_by: Throughput measurement method that will be used by your databases, (either ‘number-of-shards’ or ‘operations-per-second’)
        :param int throughput_measurement_value: Throughput value that will be used by your databases (as applies to selected measurement method). The value needs to be the maximum throughput measurement value defined in one of your databases
        :param int average_item_size_in_bytes: Relevant only to ram-and-flash clusters
               Estimated average size (measured in bytes) of the items stored in the database. The value needs to
               be the maximum average item size defined in one of your databases.  Default: 1000
        :param bool support_oss_cluster_api: Support Redis open-source (OSS) Cluster API. Default: ‘false’
        """
        pulumi.set(__self__, "memory_limit_in_gb", memory_limit_in_gb)
        pulumi.set(__self__, "modules", modules)
        pulumi.set(__self__, "quantity", quantity)
        pulumi.set(__self__, "replication", replication)
        pulumi.set(__self__, "throughput_measurement_by", throughput_measurement_by)
        pulumi.set(__self__, "throughput_measurement_value", throughput_measurement_value)
        if average_item_size_in_bytes is not None:
            pulumi.set(__self__, "average_item_size_in_bytes", average_item_size_in_bytes)
        if support_oss_cluster_api is not None:
            pulumi.set(__self__, "support_oss_cluster_api", support_oss_cluster_api)

    @property
    @pulumi.getter(name="memoryLimitInGb")
    def memory_limit_in_gb(self) -> float:
        """
        Maximum memory usage that will be used for your largest planned database.
        """
        return pulumi.get(self, "memory_limit_in_gb")

    @property
    @pulumi.getter
    def modules(self) -> Sequence[str]:
        """
        a list of modules that will be used by the databases in this subscription. Not currently compatible with ‘ram-and-flash’ memory storage.
        Example: `modules = ["RedisJSON", RedisBloom"]`
        """
        return pulumi.get(self, "modules")

    @property
    @pulumi.getter
    def quantity(self) -> int:
        """
        The planned number of databases in the subscription
        """
        return pulumi.get(self, "quantity")

    @property
    @pulumi.getter
    def replication(self) -> bool:
        """
        Databases replication. Set to `true` if any of your databases will use replication
        """
        return pulumi.get(self, "replication")

    @property
    @pulumi.getter(name="throughputMeasurementBy")
    def throughput_measurement_by(self) -> str:
        """
        Throughput measurement method that will be used by your databases, (either ‘number-of-shards’ or ‘operations-per-second’)
        """
        return pulumi.get(self, "throughput_measurement_by")

    @property
    @pulumi.getter(name="throughputMeasurementValue")
    def throughput_measurement_value(self) -> int:
        """
        Throughput value that will be used by your databases (as applies to selected measurement method). The value needs to be the maximum throughput measurement value defined in one of your databases
        """
        return pulumi.get(self, "throughput_measurement_value")

    @property
    @pulumi.getter(name="averageItemSizeInBytes")
    def average_item_size_in_bytes(self) -> Optional[int]:
        """
        Relevant only to ram-and-flash clusters
        Estimated average size (measured in bytes) of the items stored in the database. The value needs to
        be the maximum average item size defined in one of your databases.  Default: 1000
        """
        return pulumi.get(self, "average_item_size_in_bytes")

    @property
    @pulumi.getter(name="supportOssClusterApi")
    def support_oss_cluster_api(self) -> Optional[bool]:
        """
        Support Redis open-source (OSS) Cluster API. Default: ‘false’
        """
        return pulumi.get(self, "support_oss_cluster_api")


@pulumi.output_type
class SubscriptionDatabaseAlert(dict):
    def __init__(__self__, *,
                 name: str,
                 value: int):
        """
        :param str name: Alert name
        :param int value: Alert value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Alert name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Alert value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SubscriptionDatabaseModule(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the Redis database module to enable
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Redis database module to enable
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDataPersistenceDataPersistenceResult(dict):
    def __init__(__self__, *,
                 description: str,
                 name: str):
        """
        :param str description: A meaningful description of the data persistence option.
        :param str name: The identifier of the data persistence option.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A meaningful description of the data persistence option.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier of the data persistence option.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDatabaseAlertResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: int):
        """
        :param str name: The name of the database to filter returned databases
        :param int value: The alert value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the database to filter returned databases
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        The alert value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDatabaseModuleResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the database to filter returned databases
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the database to filter returned databases
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDatabaseModulesModuleResult(dict):
    def __init__(__self__, *,
                 description: str,
                 name: str):
        """
        :param str description: A meaningful description of the database module
        :param str name: The identifier assigned by the database module
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A meaningful description of the database module
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier assigned by the database module
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRegionsRegionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 provider_name: str):
        """
        :param str name: The identifier assigned by the cloud provider, (for example `eu-west-1` for `AWS`)
        :param str provider_name: The name of the cloud provider to filter returned regions, (accepted values are `AWS` or `GCP`).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider_name", provider_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier assigned by the cloud provider, (for example `eu-west-1` for `AWS`)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        The name of the cloud provider to filter returned regions, (accepted values are `AWS` or `GCP`).
        """
        return pulumi.get(self, "provider_name")


@pulumi.output_type
class GetSubscriptionCloudProviderResult(dict):
    def __init__(__self__, *,
                 cloud_account_id: str,
                 provider: str,
                 regions: Sequence['outputs.GetSubscriptionCloudProviderRegionResult']):
        """
        :param str cloud_account_id: Cloud account identifier, (A Cloud Account Id = 1 implies using Redis Labs internal cloud account)
        :param str provider: The cloud provider to use with the subscription, (either `AWS` or `GCP`)
        :param Sequence['GetSubscriptionCloudProviderRegionArgs'] regions: Deployment region as defined by cloud provider
        """
        pulumi.set(__self__, "cloud_account_id", cloud_account_id)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "regions", regions)

    @property
    @pulumi.getter(name="cloudAccountId")
    def cloud_account_id(self) -> str:
        """
        Cloud account identifier, (A Cloud Account Id = 1 implies using Redis Labs internal cloud account)
        """
        return pulumi.get(self, "cloud_account_id")

    @property
    @pulumi.getter
    def provider(self) -> str:
        """
        The cloud provider to use with the subscription, (either `AWS` or `GCP`)
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def regions(self) -> Sequence['outputs.GetSubscriptionCloudProviderRegionResult']:
        """
        Deployment region as defined by cloud provider
        """
        return pulumi.get(self, "regions")


@pulumi.output_type
class GetSubscriptionCloudProviderRegionResult(dict):
    def __init__(__self__, *,
                 multiple_availability_zones: bool,
                 networking_vpc_id: str,
                 networks: Sequence['outputs.GetSubscriptionCloudProviderRegionNetworkResult'],
                 preferred_availability_zones: Sequence[str],
                 region: str):
        """
        :param bool multiple_availability_zones: Support deployment on multiple availability zones within the selected region
        :param str networking_vpc_id: VPC id for the generated network
        :param Sequence['GetSubscriptionCloudProviderRegionNetworkArgs'] networks: List of generated network configuration
        :param Sequence[str] preferred_availability_zones: List of availability zones used
        :param str region: Deployment region as defined by cloud provider
        """
        pulumi.set(__self__, "multiple_availability_zones", multiple_availability_zones)
        pulumi.set(__self__, "networking_vpc_id", networking_vpc_id)
        pulumi.set(__self__, "networks", networks)
        pulumi.set(__self__, "preferred_availability_zones", preferred_availability_zones)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="multipleAvailabilityZones")
    def multiple_availability_zones(self) -> bool:
        """
        Support deployment on multiple availability zones within the selected region
        """
        return pulumi.get(self, "multiple_availability_zones")

    @property
    @pulumi.getter(name="networkingVpcId")
    def networking_vpc_id(self) -> str:
        """
        VPC id for the generated network
        """
        return pulumi.get(self, "networking_vpc_id")

    @property
    @pulumi.getter
    def networks(self) -> Sequence['outputs.GetSubscriptionCloudProviderRegionNetworkResult']:
        """
        List of generated network configuration
        """
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter(name="preferredAvailabilityZones")
    def preferred_availability_zones(self) -> Sequence[str]:
        """
        List of availability zones used
        """
        return pulumi.get(self, "preferred_availability_zones")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Deployment region as defined by cloud provider
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetSubscriptionCloudProviderRegionNetworkResult(dict):
    def __init__(__self__, *,
                 networking_deployment_cidr: str,
                 networking_subnet_id: str,
                 networking_vpc_id: str):
        """
        :param str networking_deployment_cidr: Deployment CIDR mask for the generated
        :param str networking_subnet_id: The subnet that the subscription deploys into
        :param str networking_vpc_id: VPC id for the generated network
        """
        pulumi.set(__self__, "networking_deployment_cidr", networking_deployment_cidr)
        pulumi.set(__self__, "networking_subnet_id", networking_subnet_id)
        pulumi.set(__self__, "networking_vpc_id", networking_vpc_id)

    @property
    @pulumi.getter(name="networkingDeploymentCidr")
    def networking_deployment_cidr(self) -> str:
        """
        Deployment CIDR mask for the generated
        """
        return pulumi.get(self, "networking_deployment_cidr")

    @property
    @pulumi.getter(name="networkingSubnetId")
    def networking_subnet_id(self) -> str:
        """
        The subnet that the subscription deploys into
        """
        return pulumi.get(self, "networking_subnet_id")

    @property
    @pulumi.getter(name="networkingVpcId")
    def networking_vpc_id(self) -> str:
        """
        VPC id for the generated network
        """
        return pulumi.get(self, "networking_vpc_id")


@pulumi.output_type
class GetSubscriptionPeeringsPeeringResult(dict):
    def __init__(__self__, *,
                 aws_account_id: str,
                 aws_peering_id: str,
                 gcp_network_name: str,
                 gcp_peering_id: str,
                 gcp_project_id: str,
                 gcp_redis_network_name: str,
                 gcp_redis_project_id: str,
                 peering_id: int,
                 provider_name: str,
                 region: str,
                 status: str,
                 vpc_cidr: str,
                 vpc_id: str):
        """
        :param str aws_account_id: AWS account id that the VPC to be peered lives in
        :param str aws_peering_id: Identifier of the AWS cloud peering
        :param str gcp_network_name: The name of the network to be peered
        :param str gcp_peering_id: Identifier of the cloud peering
        :param str gcp_project_id: GCP project ID that the VPC to be peered lives in
        :param str gcp_redis_network_name: The name of the Redis Enterprise Cloud network to be peered
        :param str gcp_redis_project_id: Identifier of the Redis Enterprise Cloud GCP project to be peered
        :param int peering_id: ID of the subscription peering
        :param str provider_name: The name of the cloud provider. (either `AWS` or `GCP`)
        :param str region: AWS Region that the VPC to be peered lives in
        :param str status: Current status of the peering - `initiating-request`, `pending-acceptance`, `active`, `inactive` or `failed`.
        :param str vpc_cidr: CIDR range of the VPC to be peered
        :param str vpc_id: Identifier of the VPC to be peered
        """
        pulumi.set(__self__, "aws_account_id", aws_account_id)
        pulumi.set(__self__, "aws_peering_id", aws_peering_id)
        pulumi.set(__self__, "gcp_network_name", gcp_network_name)
        pulumi.set(__self__, "gcp_peering_id", gcp_peering_id)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "gcp_redis_network_name", gcp_redis_network_name)
        pulumi.set(__self__, "gcp_redis_project_id", gcp_redis_project_id)
        pulumi.set(__self__, "peering_id", peering_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "vpc_cidr", vpc_cidr)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> str:
        """
        AWS account id that the VPC to be peered lives in
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="awsPeeringId")
    def aws_peering_id(self) -> str:
        """
        Identifier of the AWS cloud peering
        """
        return pulumi.get(self, "aws_peering_id")

    @property
    @pulumi.getter(name="gcpNetworkName")
    def gcp_network_name(self) -> str:
        """
        The name of the network to be peered
        """
        return pulumi.get(self, "gcp_network_name")

    @property
    @pulumi.getter(name="gcpPeeringId")
    def gcp_peering_id(self) -> str:
        """
        Identifier of the cloud peering
        """
        return pulumi.get(self, "gcp_peering_id")

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        GCP project ID that the VPC to be peered lives in
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter(name="gcpRedisNetworkName")
    def gcp_redis_network_name(self) -> str:
        """
        The name of the Redis Enterprise Cloud network to be peered
        """
        return pulumi.get(self, "gcp_redis_network_name")

    @property
    @pulumi.getter(name="gcpRedisProjectId")
    def gcp_redis_project_id(self) -> str:
        """
        Identifier of the Redis Enterprise Cloud GCP project to be peered
        """
        return pulumi.get(self, "gcp_redis_project_id")

    @property
    @pulumi.getter(name="peeringId")
    def peering_id(self) -> int:
        """
        ID of the subscription peering
        """
        return pulumi.get(self, "peering_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        The name of the cloud provider. (either `AWS` or `GCP`)
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        AWS Region that the VPC to be peered lives in
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of the peering - `initiating-request`, `pending-acceptance`, `active`, `inactive` or `failed`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="vpcCidr")
    def vpc_cidr(self) -> str:
        """
        CIDR range of the VPC to be peered
        """
        return pulumi.get(self, "vpc_cidr")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        Identifier of the VPC to be peered
        """
        return pulumi.get(self, "vpc_id")


