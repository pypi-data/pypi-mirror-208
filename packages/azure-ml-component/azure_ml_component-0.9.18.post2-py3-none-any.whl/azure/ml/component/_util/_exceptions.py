# ---------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# ---------------------------------------------------------

import re
import sys
import traceback
from enum import Enum
from functools import wraps
from typing import Union

from azureml._common.exceptions import AzureMLException
from msrest.exceptions import HttpOperationError

from azure.ml.component._restclients.designer.exceptions import ComponentServiceError, HttpResponseError, \
    AutoGenClientError
from azureml.exceptions._azureml_exception import UserErrorException
from azureml.exceptions import ExperimentExecutionException, ActivityFailedException


# The following usererrors are used to summarize different kinds of user errors in the dashboard.
# TODO: Refine all directly raised UserErrorException to several different kinds of exceptions.
class PipelineValidationError(UserErrorException):
    """
    PipelineComponent level validation error.
    """

    UNKNOWN = 'Unknown'
    # ModuleCycle error situation is: a cycle generated by a set of module nodes, like:
    # module1.input = module3.output
    # module2.input = module1.output
    # module3,input = module2.output
    MODULE_CYCLE = 'ModuleCycle'
    # PipelineRecursion error situation is: there is a loop between pipelines, like:
    # def pipeline1():
    #    pipeline2()
    # def pipeline2():
    #    pipeline1()
    PIPELINE_RECURSION = 'PipelineRecursion'
    EMPTY_PIPELINE = 'EmptyPipeline'

    AGGREGATED = 'Aggregated'

    def __init__(self, message, inner_exception=None, error_type=UNKNOWN):
        super().__init__(message)
        self.inner_exception = inner_exception
        self.error_type = error_type


class ComponentValidationError(UserErrorException):
    """
    Exception raised when the component validation fails.
    """

    UNKNOWN = 'Unknown'
    COMPUTE_TARGET_NOT_SPECIFIED = 'ComputeTargetNotSpecified'
    DATASTORE_NOT_EXIST = 'DatastoreNotExist'
    INVALID_DATASTORE_TYPE = 'InvalidDatastoreType'
    INVALID_INPUT = 'InvalidInput'
    INVALID_PARAMETER = 'InvalidParameter'
    INVALID_RUNSETTING_PARAMETER = 'InvalidRunSettingParameter'
    MISSING_INPUT = 'MissingInput'
    MISSING_PARAMETER = 'MissingParameter'
    MISSING_RUNSETTING_PARAMETER = 'MissingRunSettingParameter'
    NOT_IMPLEMENTED_ERROR = 'NotImplementedError'
    PARAMETER_TYPE_MISMATCH = 'ParameterTypeMismatch'
    UNUSED_PARAMETER = "UnusedParameter"
    MULTIPLE_TYPES_ASSIGNMENT = "MultipleTypesAssignment"
    REQUIRED_PARAMETER_OPTIONAL = "RequiredParameterOptional"
    DEPRECATED_FIELD = 'DeprecatedField'

    def __init__(self, message, inner_exception=None, error_type=UNKNOWN):
        super().__init__(message)
        self.inner_exception = inner_exception
        self.error_type = error_type


class KeywordError(UserErrorException):
    """Super class of all type keyword error."""
    def __init__(self, message):
        super().__init__(message)


class UnexpectedKeywordError(KeywordError):
    """Exception raised when an unexpected keyword parameter is provided in dynamic functions."""

    def __init__(self, func_name, keyword, keywords=None):
        message = "%s() got an unexpected keyword argument %r" % (func_name, keyword)
        message += ", valid keywords: %s." % ', '.join('%r' % key for key in keywords) if keywords else "."
        super().__init__(message)


class UnexpectedAttributeError(KeywordError, AttributeError):
    """Exception raised when an unexpected keyword is invoked by attribute, e.g. inputs.invalid_key"""

    def __init__(self, keyword, keywords=None):
        message = "Got an unexpected attribute %r" % keyword
        message += ", valid attributes: %s." % ', '.join('%r' % key for key in keywords) if keywords else "."
        KeywordError.__init__(self, message)


class MultipleValueError(KeywordError):
    """Exception raised when giving multiple value of a keyword parameter in dynamic functions."""

    def __init__(self, func_name, keyword):
        message = "%s() got multiple values for argument %r." % (func_name, keyword)
        super().__init__(message)


class MissingPositionalArgsError(KeywordError):
    """Exception raised when missing positional keyword parameter in dynamic functions."""

    def __init__(self, func_name, missing_args):
        message = "%s() missing %d required positional argument(s): %s." % (
            func_name, len(missing_args), ', '.join('%r' % key for key in missing_args) if missing_args else ".")
        super().__init__(message)


class TooManyPositionalArgsError(KeywordError):
    """Exception raised when too many positional arguments is provided in dynamic functions."""

    def __init__(self, func_name, min_number, max_number, given_number):
        message = "%s() takes %s positional argument but %d were given." % (
            func_name, min_number if min_number == max_number else f'{min_number} to {max_number}', given_number)
        super().__init__(message)


class InvalidTargetSpecifiedError(UserErrorException):
    """Exception raised when an invalid target parameter is provided."""

    def __init__(self, message):
        super().__init__(message)


class CustomerCodeError(UserErrorException):
    """Exception raised when user's code has errors."""
    def __init__(self, error_message, inner_exception=None,):
        msg = "There are some problems in user script, error message: {}".format(error_message)
        super(CustomerCodeError, self).__init__(msg, inner_exception=inner_exception)


class CannotSetAttributeError(UserErrorException):
    """Exception raised when a user try setting attributes of inputs/outputs."""
    def __init__(self, object_name):
        msg = "It is not allowed to set attribute of %r." % object_name
        super(CannotSetAttributeError, self).__init__(msg)


class ExclusiveOptionError(UserErrorException):
    """Exception raised when user specify two or more exclusive option."""
    def __init__(self, **option_dict):
        msg = "Only one can be specified in %s, got %s." % (list(option_dict.keys()), option_dict)
        super(ExclusiveOptionError, self).__init__(msg)


class UnsupportedError(UserErrorException):
    """Exception raised when unsupported scenario occurs."""
    def __init__(self, msg):
        super(UnsupportedError, self).__init__(msg)


class UnsupportedParameterKindError(UnsupportedError):
    """Exception raised when a user try setting attributes of inputs/outputs."""
    def __init__(self, func_name, is_create=False):
        if is_create:
            msg = "%r: Component.create does not support dsl pipeline with *args or **kwargs as parameters."
        else:
            msg = "%r: dsl pipeline does not accept *args as parameters."
        super(UnsupportedParameterKindError, self).__init__(msg % func_name)


class UnsupportedOutputAnnotationError(UnsupportedError):
    """Exception raised when define pipeline parameter with Output annotation."""
    def __init__(self, func_name, param_name):
        msg = "%r: Unsupported parameter %r with annotation 'Output' in dsl pipeline."
        super(UnsupportedOutputAnnotationError, self).__init__(msg % (func_name, param_name))


class YamlLoadingError(UserErrorException):
    """Exception raised when load yaml failed."""
    def __init__(self, yaml_file, inner_exception):
        msg = "Failed to load yaml file %r, only local file with YAML format is supported"
        super(YamlLoadingError, self).__init__(msg % yaml_file, inner_exception=inner_exception)


# region dsl component
class NoDslComponentError(UserErrorException):
    """Exception when no valid dsl component found in specific file."""

    def __init__(self, file, name=None):
        """Error message inits here."""
        if name:
            super().__init__("No dsl.component with name %r found in %r." % (name, file))
        else:
            super().__init__("No dsl.component found in %r." % file)


class RequiredComponentNameError(UserErrorException):
    """Exception when multiple dsl.components are found and no component name specified."""

    def __init__(self, file):
        """Error message inits here."""
        super().__init__("More than one dsl.component found in %r, '--name' parameter is required." % file)


class TooManyDSLComponentsError(UserErrorException):
    """Exception when multiple dsl.components are found in single component entry."""

    def __init__(self, count, file, component_name=None):
        """Error message inits here."""
        if not component_name:
            msg = "Only one dsl.component is allowed per file, {} found in {}".format(count, file)
        else:
            msg = "More than one dsl.component with name %r found in %r, count %d." % (component_name, file, count)
        super().__init__(msg)


class RequiredParamParsingError(UserErrorException):
    """This error indicates that a parameter is required but not exists in the command line."""

    def __init__(self, name, arg_string):
        """Init the error with the parameter name and its arg string."""
        msg = "'%s' cannot be None since it is not optional. " % name + \
              "Please make sure command option '%s' exists." % arg_string
        super().__init__(msg)


class DSLComponentDefiningError(UserErrorException):
    """This error indicates that the user define a dsl.component in an incorrect way."""

    def __init__(self, cause):
        """Init the error with the cause which causes the wrong dsl.component."""
        super().__init__("Defining the component failed due to '%s'." % cause)

# end region


class ErrorCategory(Enum):
    # This error indicates that the user provided data is incorrect and causes backend 40x exception
    MTUserError = 'MTUserError'
    SDKUserError = 'SDKUserError'  # This error indicates that the user provided parameter doesn't pass validation
    CustomerUserError = 'CustomerUserError'  # This error indicates that the user's code has errors

    MTError = 'MTError'  # This error indicates that backend has some problems
    InternalSDKError = 'InternalSDKError'  # This error indicates that our package has some problems
    ExternalSDKError = 'ExternalSDKError'  # This error indicates that some dependent packages has problems


def _is_dsl_pipeline_customer_code_error():
    """Check whether the error is raised by customer code in dsl.pipeline"""
    _, _, exc_traceback = sys.exc_info()
    if exc_traceback is None:
        return False
    # This is the frame where the exception is actually raises
    traceback_frame_list = [frame for frame, _ in traceback.walk_tb(exc_traceback)]
    last_frame = traceback_frame_list[-1]

    # When using exec to execute and globals are not specified, it's not able to identify error category.
    # If using exec to execute and __package__ not exist, it is classified as CustomerUserError.
    is_all_package_exists = next((frame for frame in traceback_frame_list if "__package__" not in frame.f_globals),
                                 None) is None
    if not is_all_package_exists:
        return True

    # We find the last frame which is in SDK code instead of customer code or dependencies code
    # by checking whether the package name of the frame belongs to azure.ml.component.
    pattern = r'(^azure\.ml\.component(?=\..*|$).*)'

    last_frame_in_sdk = next(
        (frame for frame in traceback_frame_list[::-1] if _assert_frame_package_name(pattern, frame)), None)
    if not last_frame_in_sdk:
        return False

    # If the last frame which raises exception is in SDK code, it is not customer error.
    if last_frame == last_frame_in_sdk:
        return False
    # If the last frame in SDK is the pipeline decorator, the exception is caused by customer code, return True
    # Otherwise the exception might be some dependency error, return False
    target_mod, target_funcs = 'azure.ml.component._pipeline_component_definition_builder', \
                               ['__call__', '_get_func_outputs']
    return last_frame_in_sdk.f_globals['__name__'] == target_mod and last_frame_in_sdk.f_code.co_name in target_funcs


def _is_wrong_func_call_traceback():
    """Check whether the error is raised due to wrong function call, including following scenarios:

    Unexpected keyword: f(unexpected=xx) for f()
    Too many positional argument: f(xx) for f()
    Repeated argument: f(a=1, a=2) for f(a)
    """
    _, _, traceback = sys.exc_info()
    # For such cases, the exception is called in the current frame, so it must not have a traceback.
    return traceback is not None and traceback.tb_next is None


def _is_user_error_from_exception_type(e: Union[Exception, None]):
    """Determine whether if an exception is user error from it's exception type."""
    # Connection error happens on user's network failure, should be user error
    if isinstance(e, ConnectionError):
        return True

    # UserErrorException and KeyboardInterrupt should be sdk user error
    if isinstance(e, (UserErrorException, KeyboardInterrupt)):
        return True

    # For OSError/IOError with error no 28: "No space left on device" should be sdk user error
    if isinstance(e, (IOError, OSError)) and e.errno == 28:
        return True


def get_error_category(e: Exception):
    # Sometimes we wrap a exception with another, eg: any exception happens when calling rest client will be wrapped
    # to a ServiceError. We need to check both current exception and it's cause to get the right category.

    if _is_user_error_from_exception_type(e) or _is_user_error_from_exception_type(e.__cause__):
        return ErrorCategory.SDKUserError
    if isinstance(e, CustomerCodeError):
        return ErrorCategory.CustomerUserError
    if _is_dsl_pipeline_customer_code_error():
        return ErrorCategory.CustomerUserError
    if isinstance(e, (ComponentServiceError, HttpResponseError)):
        code = e.status_code if isinstance(e, ComponentServiceError) else e.response.status_code
        if str(code).startswith('40'):
            # Currently all the 400/401/403/404s are treated as UserErrors.
            # Maybe it could be refined in the future according to more detailed information.
            return ErrorCategory.MTUserError
        return ErrorCategory.MTError

    # HttpOperationError is the exception raised by APIs in other AzureML SDKs.
    if isinstance(e, HttpOperationError):
        if str(e.response.status_code).startswith('40'):
            return ErrorCategory.SDKUserError
        return ErrorCategory.ExternalSDKError

    # ActivityFailedException is raised when an run submitted by user failed;
    # ExperimentExecutionException is raised when an run's output streaming is interrupted by user.
    # So currently we treat these two exceptions as UserError.
    if isinstance(e, (ActivityFailedException, ExperimentExecutionException)):
        return ErrorCategory.CustomerUserError

    # Exception inherited from AzureMLException which are not a user error should be external SDK error.
    if isinstance(e, AzureMLException):
        return ErrorCategory.ExternalSDKError

    # AutoGenClientError happens when calling service side with auto generated SDK client
    # most of them are retry-able internet issue, eg: ConnectionResetError
    # Note: put this after _is_user_error_from_exception_type call since KeyboardInterrupt is user error
    if isinstance(e, AutoGenClientError):
        return ErrorCategory.ExternalSDKError

    return classify_exception_to_internal_or_external(e)


def classify_exception_to_internal_or_external(e: Exception):
    """
    If some dependent packages (like azure and azureml) raise exception, it is classified as ExternalSDKError.
    If other packages raise exception, it is classified as InternalSDKError.
    This function will get the exception traceback and check whether the frame belongs to azure or azureml.
    If there is a frame in the traceback belongs to azure or azureml, it will be regarded as ExternalSDKError,
    otherwise it is regarded as InternalSDKError.
    """
    pattern = r'(^azure\.(?!ml\.component(\..*|$)).*|^azureml\..*)'
    _, _, exc_traceback = sys.exc_info()
    for frame, _ in traceback.walk_tb(exc_traceback):
        if _assert_frame_package_name(pattern, frame):
            return ErrorCategory.ExternalSDKError
    return ErrorCategory.InternalSDKError


def _assert_frame_package_name(pattern, frame):
    """Check the package name of frame is match pattern."""
    # f_globals records the function's module globals of the frame. And __package__ of module must be set.
    # https://docs.python.org/3/reference/import.html#__package__
    # Although __package__ is set when importing, it may happen __package__ does not exist in globals
    # when using exec to execute.
    package_name = frame.f_globals.get('__package__', "")
    return True if package_name and re.match(pattern, package_name) else False


def try_to_find_identifier_from_params(args, kwargs):
    from azure.ml.component import Component

    # If the params are for class methods, args[0] should be self
    if len(args) > 0:
        first_arg = args[0]
        if isinstance(first_arg, Component):
            return first_arg.name
    # Otherwise the function might be static/class method or unbound function, handle it specially
    # for component register, component spec's key word arg can be ["spec_file"]
    spec_keys = ["spec_file"]
    for spec_key in spec_keys:
        if spec_key in kwargs.keys():
            return str(kwargs[spec_key])
    return None


def wrap_azureml_exception_with_identifier(key="Component"):
    """This decorator tries to add component/pipeline identifier in AzuremlException.
    For example:
    class Component:
        @wrap_azureml_exception_with_identifier()
        def register():
    Exceptions from Component.register will have exception like this:
    Component: xxx failed.
    Note this wrapper should directly wrap the method,
    For example:
    @other_decorators
    @wrap_azureml_exception_with_identifier()
    def register():
    """
    def wrap_decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            try:
                return f(*args, **kwargs)
            except AzureMLException as e:
                # Try to find identifier
                identifier = try_to_find_identifier_from_params(args, kwargs)
                if identifier:
                    detail = e.message if e.message else 'failed'
                    message = '{} {!r}: {}'.format(key, identifier, detail)
                    e.message = message
                raise e

        return wrapper

    return wrap_decorator
