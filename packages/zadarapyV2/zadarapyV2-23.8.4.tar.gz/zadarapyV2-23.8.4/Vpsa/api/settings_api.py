# coding: utf-8

"""
    Zadara VPSA Storage Array REST API

     # Overview  This document outlines the methods available for administrating your Zadara Storage VPSA™. The Zadara Storage Array REST API   supports form-encoded, JSON, and XML requests, and can return either JSON or XML responses.  ## Usage  The majority of the APIs available require authentication which requires an API token to use. You can retrieve this token through the   Users section of your VPSA, or through the API using the “Return a user’s access key” API in the Users Section below.  ## Authentication Methods  The authentication token can be passed either through the access_key parameter inside of the body of the REST API request, or   through the X-Access-Key header.  ## Timeouts  By default, all operations that don’t complete within five seconds will return a message informing you that the action may take some  time to complete. When using the API, this can cause some actions, such as large volume creation, to be undesirably asynchronous.  You can specify your own timeout with the timeout parameter, in seconds, and a timeout value of -1 specifies an infinite timeout.  ## Specific Fields For Product  Some of the fields/actions used in the API should be used only for a specific product. The following tags are used to mark which   product responds to the fields/actions  VPSA Flash Array - All Flash Array VPSA  VPSA Storage Array - Hybrid VPSA  ## Questions  If you have any questions or need support involving the REST API, please contact for assistance.   # noqa: E501

    OpenAPI spec version: v23.8.4
    Contact: support@zadarastorage.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from Vpsa.api_client import ApiClient


class SettingsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def change_encryption_to_aws_kms(self, body_change_encryption_to_aws_kms, **kwargs):  # noqa: E501
        """change_encryption_to_aws_kms  # noqa: E501

        Change encryption from using Master Encryption Password to use AWS KMS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_encryption_to_aws_kms(body_change_encryption_to_aws_kms, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyChangeEncryptionToAwsKms body_change_encryption_to_aws_kms: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.change_encryption_to_aws_kms_with_http_info(body_change_encryption_to_aws_kms, **kwargs)  # noqa: E501
        else:
            (data) = self.change_encryption_to_aws_kms_with_http_info(body_change_encryption_to_aws_kms, **kwargs)  # noqa: E501
            return data

    def change_encryption_to_aws_kms_with_http_info(self, body_change_encryption_to_aws_kms, **kwargs):  # noqa: E501
        """change_encryption_to_aws_kms  # noqa: E501

        Change encryption from using Master Encryption Password to use AWS KMS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_encryption_to_aws_kms_with_http_info(body_change_encryption_to_aws_kms, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyChangeEncryptionToAwsKms body_change_encryption_to_aws_kms: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_change_encryption_to_aws_kms']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_encryption_to_aws_kms" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_change_encryption_to_aws_kms' is set
        if self.api_client.client_side_validation and ('body_change_encryption_to_aws_kms' not in params or
                                                       params['body_change_encryption_to_aws_kms'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_change_encryption_to_aws_kms` when calling `change_encryption_to_aws_kms`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_change_encryption_to_aws_kms' in params:
            body_params = params['body_change_encryption_to_aws_kms']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/aws_encryption.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def change_mtu_for_ni(self, body_change_mtu_for_ni, **kwargs):  # noqa: E501
        """change_mtu_for_ni  # noqa: E501

        Changes the MTU for a network interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_mtu_for_ni(body_change_mtu_for_ni, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyChangeMtuForNi body_change_mtu_for_ni: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.change_mtu_for_ni_with_http_info(body_change_mtu_for_ni, **kwargs)  # noqa: E501
        else:
            (data) = self.change_mtu_for_ni_with_http_info(body_change_mtu_for_ni, **kwargs)  # noqa: E501
            return data

    def change_mtu_for_ni_with_http_info(self, body_change_mtu_for_ni, **kwargs):  # noqa: E501
        """change_mtu_for_ni  # noqa: E501

        Changes the MTU for a network interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_mtu_for_ni_with_http_info(body_change_mtu_for_ni, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyChangeMtuForNi body_change_mtu_for_ni: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_change_mtu_for_ni']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_mtu_for_ni" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_change_mtu_for_ni' is set
        if self.api_client.client_side_validation and ('body_change_mtu_for_ni' not in params or
                                                       params['body_change_mtu_for_ni'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_change_mtu_for_ni` when calling `change_mtu_for_ni`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_change_mtu_for_ni' in params:
            body_params = params['body_change_mtu_for_ni']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/set_mtu.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_zcs_image_repository(self, body_create_zcs_image_repository, **kwargs):  # noqa: E501
        """create_zcs_image_repository  # noqa: E501

        Creates the ZCS image repository on the specified pool. ZCS images will be stored in this repository. 100 GB will be consumed on the specified pool for this repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_zcs_image_repository(body_create_zcs_image_repository, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyCreateZcsImageRepository body_create_zcs_image_repository: (required)
        :return: InlineResponse200111
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_zcs_image_repository_with_http_info(body_create_zcs_image_repository, **kwargs)  # noqa: E501
        else:
            (data) = self.create_zcs_image_repository_with_http_info(body_create_zcs_image_repository, **kwargs)  # noqa: E501
            return data

    def create_zcs_image_repository_with_http_info(self, body_create_zcs_image_repository, **kwargs):  # noqa: E501
        """create_zcs_image_repository  # noqa: E501

        Creates the ZCS image repository on the specified pool. ZCS images will be stored in this repository. 100 GB will be consumed on the specified pool for this repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_zcs_image_repository_with_http_info(body_create_zcs_image_repository, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyCreateZcsImageRepository body_create_zcs_image_repository: (required)
        :return: InlineResponse200111
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_create_zcs_image_repository']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_zcs_image_repository" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_create_zcs_image_repository' is set
        if self.api_client.client_side_validation and ('body_create_zcs_image_repository' not in params or
                                                       params['body_create_zcs_image_repository'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_create_zcs_image_repository` when calling `create_zcs_image_repository`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_create_zcs_image_repository' in params:
            body_params = params['body_create_zcs_image_repository']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/create_images_repository.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200111',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_zcs_image_repository(self, **kwargs):  # noqa: E501
        """delete_zcs_image_repository  # noqa: E501

        Delete the images repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_zcs_image_repository(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_zcs_image_repository_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_zcs_image_repository_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_zcs_image_repository_with_http_info(self, **kwargs):  # noqa: E501
        """delete_zcs_image_repository  # noqa: E501

        Delete the images repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_zcs_image_repository_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_zcs_image_repository" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/images_repository.json', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_defrag(self, **kwargs):  # noqa: E501
        """disable_defrag  # noqa: E501

        Disable volumes defragmentation scheduling.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_defrag(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_defrag_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.disable_defrag_with_http_info(**kwargs)  # noqa: E501
            return data

    def disable_defrag_with_http_info(self, **kwargs):  # noqa: E501
        """disable_defrag  # noqa: E501

        Disable volumes defragmentation scheduling.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_defrag_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_defrag" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/defrag_disable.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_file_access_audit_conf(self, body_disable_file_access_audit_conf, **kwargs):  # noqa: E501
        """disable_file_access_audit_conf  # noqa: E501

        Disable file access auditing configuration for the vpsa.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_file_access_audit_conf(body_disable_file_access_audit_conf, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyDisableFileAccessAuditConf body_disable_file_access_audit_conf: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_file_access_audit_conf_with_http_info(body_disable_file_access_audit_conf, **kwargs)  # noqa: E501
        else:
            (data) = self.disable_file_access_audit_conf_with_http_info(body_disable_file_access_audit_conf, **kwargs)  # noqa: E501
            return data

    def disable_file_access_audit_conf_with_http_info(self, body_disable_file_access_audit_conf, **kwargs):  # noqa: E501
        """disable_file_access_audit_conf  # noqa: E501

        Disable file access auditing configuration for the vpsa.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_file_access_audit_conf_with_http_info(body_disable_file_access_audit_conf, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyDisableFileAccessAuditConf body_disable_file_access_audit_conf: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_disable_file_access_audit_conf']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_file_access_audit_conf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_disable_file_access_audit_conf' is set
        if self.api_client.client_side_validation and ('body_disable_file_access_audit_conf' not in params or
                                                       params['body_disable_file_access_audit_conf'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_disable_file_access_audit_conf` when calling `disable_file_access_audit_conf`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_disable_file_access_audit_conf' in params:
            body_params = params['body_disable_file_access_audit_conf']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/disable_file_access_audit.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_privilege_access(self, body_disable_privilege_access, **kwargs):  # noqa: E501
        """disable_privilege_access  # noqa: E501

        Disable privilege access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_privilege_access(body_disable_privilege_access, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyDisablePrivilegeAccess body_disable_privilege_access: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_privilege_access_with_http_info(body_disable_privilege_access, **kwargs)  # noqa: E501
        else:
            (data) = self.disable_privilege_access_with_http_info(body_disable_privilege_access, **kwargs)  # noqa: E501
            return data

    def disable_privilege_access_with_http_info(self, body_disable_privilege_access, **kwargs):  # noqa: E501
        """disable_privilege_access  # noqa: E501

        Disable privilege access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_privilege_access_with_http_info(body_disable_privilege_access, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyDisablePrivilegeAccess body_disable_privilege_access: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_disable_privilege_access']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_privilege_access" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_disable_privilege_access' is set
        if self.api_client.client_side_validation and ('body_disable_privilege_access' not in params or
                                                       params['body_disable_privilege_access'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_disable_privilege_access` when calling `disable_privilege_access`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_disable_privilege_access' in params:
            body_params = params['body_disable_privilege_access']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/disable_privilege_access.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable_trim(self, **kwargs):  # noqa: E501
        """disable_trim  # noqa: E501

        Disable volumes File System scheduling.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_trim(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_trim_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.disable_trim_with_http_info(**kwargs)  # noqa: E501
            return data

    def disable_trim_with_http_info(self, **kwargs):  # noqa: E501
        """disable_trim  # noqa: E501

        Disable volumes File System scheduling.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_trim_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable_trim" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/trim_disable.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_metering_database(self, **kwargs):  # noqa: E501
        """download_metering_database  # noqa: E501

        Download the metering database  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_metering_database(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Default
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.download_metering_database_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.download_metering_database_with_http_info(**kwargs)  # noqa: E501
            return data

    def download_metering_database_with_http_info(self, **kwargs):  # noqa: E501
        """download_metering_database  # noqa: E501

        Download the metering database  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_metering_database_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Default
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_metering_database" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/metering_db.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Default',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_defrag(self, **kwargs):  # noqa: E501
        """enable_defrag  # noqa: E501

        Enable volumes defragmentation scheduling.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_defrag(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_defrag_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.enable_defrag_with_http_info(**kwargs)  # noqa: E501
            return data

    def enable_defrag_with_http_info(self, **kwargs):  # noqa: E501
        """enable_defrag  # noqa: E501

        Enable volumes defragmentation scheduling.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_defrag_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_defrag" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/defrag_enable.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_privilege_access(self, **kwargs):  # noqa: E501
        """enable_privilege_access  # noqa: E501

        Enable privilege access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_privilege_access(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_privilege_access_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.enable_privilege_access_with_http_info(**kwargs)  # noqa: E501
            return data

    def enable_privilege_access_with_http_info(self, **kwargs):  # noqa: E501
        """enable_privilege_access  # noqa: E501

        Enable privilege access.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_privilege_access_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_privilege_access" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/enable_privilege_access.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_trim(self, **kwargs):  # noqa: E501
        """enable_trim  # noqa: E501

        Enable volumes File System scheduling.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_trim(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_trim_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.enable_trim_with_http_info(**kwargs)  # noqa: E501
            return data

    def enable_trim_with_http_info(self, **kwargs):  # noqa: E501
        """enable_trim  # noqa: E501

        Enable volumes File System scheduling.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_trim_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_trim" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/trim_enable.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_app_settings(self, **kwargs):  # noqa: E501
        """get_all_app_settings  # noqa: E501

        Get all application settings. Allowed to admin only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_app_settings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200114
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_app_settings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_app_settings_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_app_settings_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_app_settings  # noqa: E501

        Get all application settings. Allowed to admin only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_app_settings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200114
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_app_settings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings_config.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200114',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_nfs_domain(self, **kwargs):  # noqa: E501
        """get_nfs_domain  # noqa: E501

        Gets the NFS Domain associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nfs_domain(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200103
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_nfs_domain_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_nfs_domain_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_nfs_domain_with_http_info(self, **kwargs):  # noqa: E501
        """get_nfs_domain  # noqa: E501

        Gets the NFS Domain associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_nfs_domain_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200103
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_nfs_domain" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/nfs_domain.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200103',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_public_ip(self, **kwargs):  # noqa: E501
        """get_public_ip  # noqa: E501

        Returns the public IP(s) associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_public_ip(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200107
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_public_ip_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_public_ip_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_public_ip_with_http_info(self, **kwargs):  # noqa: E501
        """get_public_ip  # noqa: E501

        Returns the public IP(s) associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_public_ip_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200107
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_public_ip" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/public_ips.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200107',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vpsa_flc_global(self, **kwargs):  # noqa: E501
        """get_vpsa_flc_global  # noqa: E501

        Retrieves the VPSA FLC global.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vpsa_flc_global(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200116
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_vpsa_flc_global_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_vpsa_flc_global_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_vpsa_flc_global_with_http_info(self, **kwargs):  # noqa: E501
        """get_vpsa_flc_global  # noqa: E501

        Retrieves the VPSA FLC global.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vpsa_flc_global_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200116
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vpsa_flc_global" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/flc_global.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200116',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_zcs_settings(self, **kwargs):  # noqa: E501
        """get_zcs_settings  # noqa: E501

        Get the APP repository details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_zcs_settings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200110
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_zcs_settings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_zcs_settings_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_zcs_settings_with_http_info(self, **kwargs):  # noqa: E501
        """get_zcs_settings  # noqa: E501

        Get the APP repository details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_zcs_settings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200110
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_zcs_settings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/container_service.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200110',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_all_vc_capabilities(self, **kwargs):  # noqa: E501
        """list_all_vc_capabilities  # noqa: E501

        Returns a list of all VC capabilities.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_all_vc_capabilities(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200115
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_all_vc_capabilities_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_all_vc_capabilities_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_all_vc_capabilities_with_http_info(self, **kwargs):  # noqa: E501
        """list_all_vc_capabilities  # noqa: E501

        Returns a list of all VC capabilities.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_all_vc_capabilities_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200115
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_all_vc_capabilities" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/vc_capabilities.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200115',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def migrate_zcs_image_repository(self, body_migrate_zcs_image_repository, **kwargs):  # noqa: E501
        """migrate_zcs_image_repository  # noqa: E501

        Migrate the images repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.migrate_zcs_image_repository(body_migrate_zcs_image_repository, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyMigrateZcsImageRepository body_migrate_zcs_image_repository: (required)
        :return: InlineResponse200112
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.migrate_zcs_image_repository_with_http_info(body_migrate_zcs_image_repository, **kwargs)  # noqa: E501
        else:
            (data) = self.migrate_zcs_image_repository_with_http_info(body_migrate_zcs_image_repository, **kwargs)  # noqa: E501
            return data

    def migrate_zcs_image_repository_with_http_info(self, body_migrate_zcs_image_repository, **kwargs):  # noqa: E501
        """migrate_zcs_image_repository  # noqa: E501

        Migrate the images repository.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.migrate_zcs_image_repository_with_http_info(body_migrate_zcs_image_repository, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyMigrateZcsImageRepository body_migrate_zcs_image_repository: (required)
        :return: InlineResponse200112
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_migrate_zcs_image_repository']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method migrate_zcs_image_repository" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_migrate_zcs_image_repository' is set
        if self.api_client.client_side_validation and ('body_migrate_zcs_image_repository' not in params or
                                                       params['body_migrate_zcs_image_repository'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_migrate_zcs_image_repository` when calling `migrate_zcs_image_repository`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_migrate_zcs_image_repository' in params:
            body_params = params['body_migrate_zcs_image_repository']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/migrate_images_repository.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200112',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pause_file_access_audit_conf(self, body_pause_file_access_audit_conf, **kwargs):  # noqa: E501
        """pause_file_access_audit_conf  # noqa: E501

        Pause file access auditing configuration for the vpsa.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pause_file_access_audit_conf(body_pause_file_access_audit_conf, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyPauseFileAccessAuditConf body_pause_file_access_audit_conf: (required)
        :return: InlineResponse200109
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pause_file_access_audit_conf_with_http_info(body_pause_file_access_audit_conf, **kwargs)  # noqa: E501
        else:
            (data) = self.pause_file_access_audit_conf_with_http_info(body_pause_file_access_audit_conf, **kwargs)  # noqa: E501
            return data

    def pause_file_access_audit_conf_with_http_info(self, body_pause_file_access_audit_conf, **kwargs):  # noqa: E501
        """pause_file_access_audit_conf  # noqa: E501

        Pause file access auditing configuration for the vpsa.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pause_file_access_audit_conf_with_http_info(body_pause_file_access_audit_conf, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyPauseFileAccessAuditConf body_pause_file_access_audit_conf: (required)
        :return: InlineResponse200109
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_pause_file_access_audit_conf']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pause_file_access_audit_conf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_pause_file_access_audit_conf' is set
        if self.api_client.client_side_validation and ('body_pause_file_access_audit_conf' not in params or
                                                       params['body_pause_file_access_audit_conf'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_pause_file_access_audit_conf` when calling `pause_file_access_audit_conf`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_pause_file_access_audit_conf' in params:
            body_params = params['body_pause_file_access_audit_conf']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/configure_file_access_audit.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200109',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_encryption_kms(self, **kwargs):  # noqa: E501
        """remove_encryption_kms  # noqa: E501

        Remove encryption KMS on the VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_encryption_kms(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_encryption_kms_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.remove_encryption_kms_with_http_info(**kwargs)  # noqa: E501
            return data

    def remove_encryption_kms_with_http_info(self, **kwargs):  # noqa: E501
        """remove_encryption_kms  # noqa: E501

        Remove encryption KMS on the VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_encryption_kms_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_encryption_kms" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/remove_encryption_kms.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_encryption_password(self, **kwargs):  # noqa: E501
        """remove_encryption_password  # noqa: E501

        Remove any encryption configured on your VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_encryption_password(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_encryption_password_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.remove_encryption_password_with_http_info(**kwargs)  # noqa: E501
            return data

    def remove_encryption_password_with_http_info(self, **kwargs):  # noqa: E501
        """remove_encryption_password  # noqa: E501

        Remove any encryption configured on your VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_encryption_password_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_encryption_password" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/clear_encryption.json', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def restore_aws_kms_store(self, body_restore_aws_kms_store, **kwargs):  # noqa: E501
        """restore_aws_kms_store  # noqa: E501

        Restore the AWS KMS details for your VPSA, if cleared.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_aws_kms_store(body_restore_aws_kms_store, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyRestoreAwsKmsStore body_restore_aws_kms_store: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.restore_aws_kms_store_with_http_info(body_restore_aws_kms_store, **kwargs)  # noqa: E501
        else:
            (data) = self.restore_aws_kms_store_with_http_info(body_restore_aws_kms_store, **kwargs)  # noqa: E501
            return data

    def restore_aws_kms_store_with_http_info(self, body_restore_aws_kms_store, **kwargs):  # noqa: E501
        """restore_aws_kms_store  # noqa: E501

        Restore the AWS KMS details for your VPSA, if cleared.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_aws_kms_store_with_http_info(body_restore_aws_kms_store, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyRestoreAwsKmsStore body_restore_aws_kms_store: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_restore_aws_kms_store']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restore_aws_kms_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_restore_aws_kms_store' is set
        if self.api_client.client_side_validation and ('body_restore_aws_kms_store' not in params or
                                                       params['body_restore_aws_kms_store'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_restore_aws_kms_store` when calling `restore_aws_kms_store`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_restore_aws_kms_store' in params:
            body_params = params['body_restore_aws_kms_store']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/restore_encryption_aws.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def restore_encryption_password(self, body_restore_encryption_password, **kwargs):  # noqa: E501
        """restore_encryption_password  # noqa: E501

        Restore the Master Encryption Password for your VPSA, if cleared.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_encryption_password(body_restore_encryption_password, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyRestoreEncryptionPassword body_restore_encryption_password: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.restore_encryption_password_with_http_info(body_restore_encryption_password, **kwargs)  # noqa: E501
        else:
            (data) = self.restore_encryption_password_with_http_info(body_restore_encryption_password, **kwargs)  # noqa: E501
            return data

    def restore_encryption_password_with_http_info(self, body_restore_encryption_password, **kwargs):  # noqa: E501
        """restore_encryption_password  # noqa: E501

        Restore the Master Encryption Password for your VPSA, if cleared.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_encryption_password_with_http_info(body_restore_encryption_password, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyRestoreEncryptionPassword body_restore_encryption_password: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_restore_encryption_password']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restore_encryption_password" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_restore_encryption_password' is set
        if self.api_client.client_side_validation and ('body_restore_encryption_password' not in params or
                                                       params['body_restore_encryption_password'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_restore_encryption_password` when calling `restore_encryption_password`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_restore_encryption_password' in params:
            body_params = params['body_restore_encryption_password']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/restore_encryption.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def restore_encryption_password_kmip(self, body_restore_encryption_password_kmip, **kwargs):  # noqa: E501
        """restore_encryption_password_kmip  # noqa: E501

        Restore the KMIP KMS details for your VPSA, if cleared.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_encryption_password_kmip(body_restore_encryption_password_kmip, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyRestoreEncryptionPasswordKmip body_restore_encryption_password_kmip: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.restore_encryption_password_kmip_with_http_info(body_restore_encryption_password_kmip, **kwargs)  # noqa: E501
        else:
            (data) = self.restore_encryption_password_kmip_with_http_info(body_restore_encryption_password_kmip, **kwargs)  # noqa: E501
            return data

    def restore_encryption_password_kmip_with_http_info(self, body_restore_encryption_password_kmip, **kwargs):  # noqa: E501
        """restore_encryption_password_kmip  # noqa: E501

        Restore the KMIP KMS details for your VPSA, if cleared.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.restore_encryption_password_kmip_with_http_info(body_restore_encryption_password_kmip, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyRestoreEncryptionPasswordKmip body_restore_encryption_password_kmip: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_restore_encryption_password_kmip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method restore_encryption_password_kmip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_restore_encryption_password_kmip' is set
        if self.api_client.client_side_validation and ('body_restore_encryption_password_kmip' not in params or
                                                       params['body_restore_encryption_password_kmip'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_restore_encryption_password_kmip` when calling `restore_encryption_password_kmip`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_restore_encryption_password_kmip' in params:
            body_params = params['body_restore_encryption_password_kmip']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/restore_encryption_kmip.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_encription_pass(self, body_set_encription_pass, **kwargs):  # noqa: E501
        """set_encription_pass  # noqa: E501

        Change Master Encryption Password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_encription_pass(body_set_encription_pass, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetEncriptionPass body_set_encription_pass: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_encription_pass_with_http_info(body_set_encription_pass, **kwargs)  # noqa: E501
        else:
            (data) = self.set_encription_pass_with_http_info(body_set_encription_pass, **kwargs)  # noqa: E501
            return data

    def set_encription_pass_with_http_info(self, body_set_encription_pass, **kwargs):  # noqa: E501
        """set_encription_pass  # noqa: E501

        Change Master Encryption Password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_encription_pass_with_http_info(body_set_encription_pass, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetEncriptionPass body_set_encription_pass: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_set_encription_pass']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_encription_pass" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_set_encription_pass' is set
        if self.api_client.client_side_validation and ('body_set_encription_pass' not in params or
                                                       params['body_set_encription_pass'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_set_encription_pass` when calling `set_encription_pass`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_set_encription_pass' in params:
            body_params = params['body_set_encription_pass']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/password_encryption.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_encription_pass_or_use_aws_kms_store(self, body_set_encription_pass_or_use_aws_kms_store, **kwargs):  # noqa: E501
        """set_encription_pass_or_use_aws_kms_store  # noqa: E501

        Sets the encryption password globally on the VPSA. or Change Master Encryption Password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_encription_pass_or_use_aws_kms_store(body_set_encription_pass_or_use_aws_kms_store, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetEncriptionPassOrUseAwsKmsStore body_set_encription_pass_or_use_aws_kms_store: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_encription_pass_or_use_aws_kms_store_with_http_info(body_set_encription_pass_or_use_aws_kms_store, **kwargs)  # noqa: E501
        else:
            (data) = self.set_encription_pass_or_use_aws_kms_store_with_http_info(body_set_encription_pass_or_use_aws_kms_store, **kwargs)  # noqa: E501
            return data

    def set_encription_pass_or_use_aws_kms_store_with_http_info(self, body_set_encription_pass_or_use_aws_kms_store, **kwargs):  # noqa: E501
        """set_encription_pass_or_use_aws_kms_store  # noqa: E501

        Sets the encryption password globally on the VPSA. or Change Master Encryption Password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_encription_pass_or_use_aws_kms_store_with_http_info(body_set_encription_pass_or_use_aws_kms_store, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetEncriptionPassOrUseAwsKmsStore body_set_encription_pass_or_use_aws_kms_store: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_set_encription_pass_or_use_aws_kms_store']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_encription_pass_or_use_aws_kms_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_set_encription_pass_or_use_aws_kms_store' is set
        if self.api_client.client_side_validation and ('body_set_encription_pass_or_use_aws_kms_store' not in params or
                                                       params['body_set_encription_pass_or_use_aws_kms_store'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_set_encription_pass_or_use_aws_kms_store` when calling `set_encription_pass_or_use_aws_kms_store`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_set_encription_pass_or_use_aws_kms_store' in params:
            body_params = params['body_set_encription_pass_or_use_aws_kms_store']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/encryption.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_encryption_password_kmip(self, body_set_encryption_password_kmip, **kwargs):  # noqa: E501
        """set_encryption_password_kmip  # noqa: E501

        Change encryption from using Master Encryption Password to use KMIP KMS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_encryption_password_kmip(body_set_encryption_password_kmip, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetEncryptionPasswordKmip body_set_encryption_password_kmip: (required)
        :return: Default
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_encryption_password_kmip_with_http_info(body_set_encryption_password_kmip, **kwargs)  # noqa: E501
        else:
            (data) = self.set_encryption_password_kmip_with_http_info(body_set_encryption_password_kmip, **kwargs)  # noqa: E501
            return data

    def set_encryption_password_kmip_with_http_info(self, body_set_encryption_password_kmip, **kwargs):  # noqa: E501
        """set_encryption_password_kmip  # noqa: E501

        Change encryption from using Master Encryption Password to use KMIP KMS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_encryption_password_kmip_with_http_info(body_set_encryption_password_kmip, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetEncryptionPasswordKmip body_set_encryption_password_kmip: (required)
        :return: Default
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_set_encryption_password_kmip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_encryption_password_kmip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_set_encryption_password_kmip' is set
        if self.api_client.client_side_validation and ('body_set_encryption_password_kmip' not in params or
                                                       params['body_set_encryption_password_kmip'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_set_encryption_password_kmip` when calling `set_encryption_password_kmip`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_set_encryption_password_kmip' in params:
            body_params = params['body_set_encryption_password_kmip']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/kmip_encryption.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Default',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_global_server_connectivity_monitoring(self, body_set_global_server_connectivity_monitoring, **kwargs):  # noqa: E501
        """set_global_server_connectivity_monitoring  # noqa: E501

        Set global server connectivity monitoring  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_global_server_connectivity_monitoring(body_set_global_server_connectivity_monitoring, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetGlobalServerConnectivityMonitoring body_set_global_server_connectivity_monitoring: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_global_server_connectivity_monitoring_with_http_info(body_set_global_server_connectivity_monitoring, **kwargs)  # noqa: E501
        else:
            (data) = self.set_global_server_connectivity_monitoring_with_http_info(body_set_global_server_connectivity_monitoring, **kwargs)  # noqa: E501
            return data

    def set_global_server_connectivity_monitoring_with_http_info(self, body_set_global_server_connectivity_monitoring, **kwargs):  # noqa: E501
        """set_global_server_connectivity_monitoring  # noqa: E501

        Set global server connectivity monitoring  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_global_server_connectivity_monitoring_with_http_info(body_set_global_server_connectivity_monitoring, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetGlobalServerConnectivityMonitoring body_set_global_server_connectivity_monitoring: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_set_global_server_connectivity_monitoring']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_global_server_connectivity_monitoring" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_set_global_server_connectivity_monitoring' is set
        if self.api_client.client_side_validation and ('body_set_global_server_connectivity_monitoring' not in params or
                                                       params['body_set_global_server_connectivity_monitoring'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_set_global_server_connectivity_monitoring` when calling `set_global_server_connectivity_monitoring`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_set_global_server_connectivity_monitoring' in params:
            body_params = params['body_set_global_server_connectivity_monitoring']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/server_monitoring.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_multizone_read_mode(self, body_set_multizone_read_mode, **kwargs):  # noqa: E501
        """set_multizone_read_mode  # noqa: E501

        Sets the raid read mode associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_multizone_read_mode(body_set_multizone_read_mode, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetMultizoneReadMode body_set_multizone_read_mode: (required)
        :return: InlineResponse200105
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_multizone_read_mode_with_http_info(body_set_multizone_read_mode, **kwargs)  # noqa: E501
        else:
            (data) = self.set_multizone_read_mode_with_http_info(body_set_multizone_read_mode, **kwargs)  # noqa: E501
            return data

    def set_multizone_read_mode_with_http_info(self, body_set_multizone_read_mode, **kwargs):  # noqa: E501
        """set_multizone_read_mode  # noqa: E501

        Sets the raid read mode associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_multizone_read_mode_with_http_info(body_set_multizone_read_mode, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetMultizoneReadMode body_set_multizone_read_mode: (required)
        :return: InlineResponse200105
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_set_multizone_read_mode']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_multizone_read_mode" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_set_multizone_read_mode' is set
        if self.api_client.client_side_validation and ('body_set_multizone_read_mode' not in params or
                                                       params['body_set_multizone_read_mode'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_set_multizone_read_mode` when calling `set_multizone_read_mode`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_set_multizone_read_mode' in params:
            body_params = params['body_set_multizone_read_mode']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/raid_read_mode.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200105',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_nfs_domain(self, body_set_nfs_domain, **kwargs):  # noqa: E501
        """set_nfs_domain  # noqa: E501

        Sets the NFS Domain associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_nfs_domain(body_set_nfs_domain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetNfsDomain body_set_nfs_domain: (required)
        :return: InlineResponse200104
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_nfs_domain_with_http_info(body_set_nfs_domain, **kwargs)  # noqa: E501
        else:
            (data) = self.set_nfs_domain_with_http_info(body_set_nfs_domain, **kwargs)  # noqa: E501
            return data

    def set_nfs_domain_with_http_info(self, body_set_nfs_domain, **kwargs):  # noqa: E501
        """set_nfs_domain  # noqa: E501

        Sets the NFS Domain associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_nfs_domain_with_http_info(body_set_nfs_domain, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetNfsDomain body_set_nfs_domain: (required)
        :return: InlineResponse200104
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_set_nfs_domain']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_nfs_domain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_set_nfs_domain' is set
        if self.api_client.client_side_validation and ('body_set_nfs_domain' not in params or
                                                       params['body_set_nfs_domain'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_set_nfs_domain` when calling `set_nfs_domain`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_set_nfs_domain' in params:
            body_params = params['body_set_nfs_domain']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/nfs_domain.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200104',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_pass_policy(self, body_set_pass_policy, **kwargs):  # noqa: E501
        """set_pass_policy  # noqa: E501

        Set password policy.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_pass_policy(body_set_pass_policy, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetPassPolicy body_set_pass_policy: (required)
        :return: InlineResponse200113
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_pass_policy_with_http_info(body_set_pass_policy, **kwargs)  # noqa: E501
        else:
            (data) = self.set_pass_policy_with_http_info(body_set_pass_policy, **kwargs)  # noqa: E501
            return data

    def set_pass_policy_with_http_info(self, body_set_pass_policy, **kwargs):  # noqa: E501
        """set_pass_policy  # noqa: E501

        Set password policy.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_pass_policy_with_http_info(body_set_pass_policy, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetPassPolicy body_set_pass_policy: (required)
        :return: InlineResponse200113
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_set_pass_policy']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_pass_policy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_set_pass_policy' is set
        if self.api_client.client_side_validation and ('body_set_pass_policy' not in params or
                                                       params['body_set_pass_policy'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_set_pass_policy` when calling `set_pass_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_set_pass_policy' in params:
            body_params = params['body_set_pass_policy']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/password_policy.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200113',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_recycle_bin(self, body_set_recycle_bin, **kwargs):  # noqa: E501
        """set_recycle_bin  # noqa: E501

        Enable/Disable recycle bin for volumes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_recycle_bin(body_set_recycle_bin, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetRecycleBin body_set_recycle_bin: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_recycle_bin_with_http_info(body_set_recycle_bin, **kwargs)  # noqa: E501
        else:
            (data) = self.set_recycle_bin_with_http_info(body_set_recycle_bin, **kwargs)  # noqa: E501
            return data

    def set_recycle_bin_with_http_info(self, body_set_recycle_bin, **kwargs):  # noqa: E501
        """set_recycle_bin  # noqa: E501

        Enable/Disable recycle bin for volumes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_recycle_bin_with_http_info(body_set_recycle_bin, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetRecycleBin body_set_recycle_bin: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_set_recycle_bin']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_recycle_bin" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_set_recycle_bin' is set
        if self.api_client.client_side_validation and ('body_set_recycle_bin' not in params or
                                                       params['body_set_recycle_bin'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_set_recycle_bin` when calling `set_recycle_bin`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_set_recycle_bin' in params:
            body_params = params['body_set_recycle_bin']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/set_recycle_bin.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_smb_charset(self, body_set_smb_charset, **kwargs):  # noqa: E501
        """set_smb_charset  # noqa: E501

        Sets the smb charset associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_smb_charset(body_set_smb_charset, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetSmbCharset body_set_smb_charset: (required)
        :return: Default
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_smb_charset_with_http_info(body_set_smb_charset, **kwargs)  # noqa: E501
        else:
            (data) = self.set_smb_charset_with_http_info(body_set_smb_charset, **kwargs)  # noqa: E501
            return data

    def set_smb_charset_with_http_info(self, body_set_smb_charset, **kwargs):  # noqa: E501
        """set_smb_charset  # noqa: E501

        Sets the smb charset associated with this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_smb_charset_with_http_info(body_set_smb_charset, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetSmbCharset body_set_smb_charset: (required)
        :return: Default
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_set_smb_charset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_smb_charset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_set_smb_charset' is set
        if self.api_client.client_side_validation and ('body_set_smb_charset' not in params or
                                                       params['body_set_smb_charset'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_set_smb_charset` when calling `set_smb_charset`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_set_smb_charset' in params:
            body_params = params['body_set_smb_charset']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/smb_charset.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Default',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_smb_netbios_name(self, body_set_smb_netbios_name, **kwargs):  # noqa: E501
        """set_smb_netbios_name  # noqa: E501

        Sets the smb netbios name for this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_smb_netbios_name(body_set_smb_netbios_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetSmbNetbiosName body_set_smb_netbios_name: (required)
        :return: InlineResponse200106
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_smb_netbios_name_with_http_info(body_set_smb_netbios_name, **kwargs)  # noqa: E501
        else:
            (data) = self.set_smb_netbios_name_with_http_info(body_set_smb_netbios_name, **kwargs)  # noqa: E501
            return data

    def set_smb_netbios_name_with_http_info(self, body_set_smb_netbios_name, **kwargs):  # noqa: E501
        """set_smb_netbios_name  # noqa: E501

        Sets the smb netbios name for this VPSA.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_smb_netbios_name_with_http_info(body_set_smb_netbios_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetSmbNetbiosName body_set_smb_netbios_name: (required)
        :return: InlineResponse200106
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_set_smb_netbios_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_smb_netbios_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_set_smb_netbios_name' is set
        if self.api_client.client_side_validation and ('body_set_smb_netbios_name' not in params or
                                                       params['body_set_smb_netbios_name'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_set_smb_netbios_name` when calling `set_smb_netbios_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_set_smb_netbios_name' in params:
            body_params = params['body_set_smb_netbios_name']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/smb_netbios_name.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200106',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_smb_trusted_domains(self, body_set_smb_trusted_domains, **kwargs):  # noqa: E501
        """set_smb_trusted_domains  # noqa: E501

        Enable/Disable SMB trusted domains.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_smb_trusted_domains(body_set_smb_trusted_domains, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetSmbTrustedDomains body_set_smb_trusted_domains: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_smb_trusted_domains_with_http_info(body_set_smb_trusted_domains, **kwargs)  # noqa: E501
        else:
            (data) = self.set_smb_trusted_domains_with_http_info(body_set_smb_trusted_domains, **kwargs)  # noqa: E501
            return data

    def set_smb_trusted_domains_with_http_info(self, body_set_smb_trusted_domains, **kwargs):  # noqa: E501
        """set_smb_trusted_domains  # noqa: E501

        Enable/Disable SMB trusted domains.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_smb_trusted_domains_with_http_info(body_set_smb_trusted_domains, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodySetSmbTrustedDomains body_set_smb_trusted_domains: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_set_smb_trusted_domains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_smb_trusted_domains" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_set_smb_trusted_domains' is set
        if self.api_client.client_side_validation and ('body_set_smb_trusted_domains' not in params or
                                                       params['body_set_smb_trusted_domains'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_set_smb_trusted_domains` when calling `set_smb_trusted_domains`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_set_smb_trusted_domains' in params:
            body_params = params['body_set_smb_trusted_domains']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/smb_trusted_domains.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_audit_conf(self, **kwargs):  # noqa: E501
        """show_audit_conf  # noqa: E501

        Gets the current file access auditing configuration for the vpsa.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_audit_conf(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200108
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_audit_conf_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.show_audit_conf_with_http_info(**kwargs)  # noqa: E501
            return data

    def show_audit_conf_with_http_info(self, **kwargs):  # noqa: E501
        """show_audit_conf  # noqa: E501

        Gets the current file access auditing configuration for the vpsa.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_audit_conf_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200108
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_audit_conf" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/show_audit_config.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200108',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_defrag(self, **kwargs):  # noqa: E501
        """start_defrag  # noqa: E501

        Start volumes defragmentation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_defrag(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.start_defrag_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.start_defrag_with_http_info(**kwargs)  # noqa: E501
            return data

    def start_defrag_with_http_info(self, **kwargs):  # noqa: E501
        """start_defrag  # noqa: E501

        Start volumes defragmentation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_defrag_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_defrag" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/defrag_start.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_trim(self, **kwargs):  # noqa: E501
        """start_trim  # noqa: E501

        Start volumes File System trim.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_trim(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.start_trim_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.start_trim_with_http_info(**kwargs)  # noqa: E501
            return data

    def start_trim_with_http_info(self, **kwargs):  # noqa: E501
        """start_trim  # noqa: E501

        Start volumes File System trim.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_trim_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_trim" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/trim_start.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stop_defrag(self, **kwargs):  # noqa: E501
        """stop_defrag  # noqa: E501

        Stop volumes defragmentation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_defrag(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stop_defrag_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.stop_defrag_with_http_info(**kwargs)  # noqa: E501
            return data

    def stop_defrag_with_http_info(self, **kwargs):  # noqa: E501
        """stop_defrag  # noqa: E501

        Stop volumes defragmentation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_defrag_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_defrag" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/defrag_stop.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stop_trim(self, **kwargs):  # noqa: E501
        """stop_trim  # noqa: E501

        Stop volumes File System trim.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_trim(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stop_trim_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.stop_trim_with_http_info(**kwargs)  # noqa: E501
            return data

    def stop_trim_with_http_info(self, **kwargs):  # noqa: E501
        """stop_trim  # noqa: E501

        Stop volumes File System trim.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_trim_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_trim" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/trim_stop.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_zcs_settings(self, body_update_zcs_settings, **kwargs):  # noqa: E501
        """update_zcs_settings  # noqa: E501

        Update the container service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_zcs_settings(body_update_zcs_settings, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyUpdateZcsSettings body_update_zcs_settings: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_zcs_settings_with_http_info(body_update_zcs_settings, **kwargs)  # noqa: E501
        else:
            (data) = self.update_zcs_settings_with_http_info(body_update_zcs_settings, **kwargs)  # noqa: E501
            return data

    def update_zcs_settings_with_http_info(self, body_update_zcs_settings, **kwargs):  # noqa: E501
        """update_zcs_settings  # noqa: E501

        Update the container service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_zcs_settings_with_http_info(body_update_zcs_settings, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BodyUpdateZcsSettings body_update_zcs_settings: (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body_update_zcs_settings']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_zcs_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body_update_zcs_settings' is set
        if self.api_client.client_side_validation and ('body_update_zcs_settings' not in params or
                                                       params['body_update_zcs_settings'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body_update_zcs_settings` when calling `update_zcs_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body_update_zcs_settings' in params:
            body_params = params['body_update_zcs_settings']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/settings/container_service.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
