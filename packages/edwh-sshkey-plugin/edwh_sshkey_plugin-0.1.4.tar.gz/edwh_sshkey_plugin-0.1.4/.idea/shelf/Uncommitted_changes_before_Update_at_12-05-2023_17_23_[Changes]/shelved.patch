Index: src/edwh_sshkey_plugin/fabfile.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from fabric import task\nfrom datetime import datetime\nfrom yaml.loader import SafeLoader\nimport pathlib\nimport yaml\nimport time\nimport os\nimport subprocess\nimport platform\n\n# the path where the yaml file with the keys is stored\nYAML_KEYS_PATH = pathlib.Path(\"~/.ssh/known_keys.yaml\").expanduser()\n\n\ndef create_new_keyholder():\n    \"\"\"\n    When a user wants to add a keys for the first time, this function will be called.\n    It's to create a new yaml file where the keys will be stored.\n    \"\"\"\n    with open(YAML_KEYS_PATH, \"x\") as new_key_holder:\n        new_key_holder.close()\n\n\ndef create_new_yaml_file_if_not_exists():\n    \"\"\"\n    Checks if the yaml file exists, if not it will create a new one.\n    \"\"\"\n    if not YAML_KEYS_PATH.exists():\n        create_new_keyholder()\n\n\ndef open_new_keyholder(read: bool):\n    \"\"\"\n    To open the yaml file, this function will be called.\n    \"\"\"\n    if YAML_KEYS_PATH.exists():\n        return open(YAML_KEYS_PATH, \"r\" if read else \"w\")\n    else:\n        create_new_keyholder()\n\n\ndef get_keys_from_keyholder():\n    \"\"\"\n    This function retrieves keys from a keyholder.\n\n    The function first opens a new keyholder and loads its contents as a dictionary using the yaml library.\n    If the keyholder is empty, the function prints an error message and exits with code 255.\n    Otherwise, it returns a dictionary of keys from the keyholder.\n\n    :return: A dictionary of keys from the keyholder.\n    \"\"\"\n    # It opens the keyholder and loads its contents as a dictionary using the yaml library.\n    key_holder = open_new_keyholder(True)\n    key_db: dict = yaml.load(key_holder, Loader=SafeLoader)\n    # This checks if the keyholder is empty. If empty -> exit with code 255\n    if key_db is None:\n        print(\n            \"functionality for generating local keys automaticly and adding them to the keyholder currently isn't supported\"\n        )\n        print(\"please run create to generate a new key\")\n        exit(255)\n    # This returns a dictionary of keys from the keyholder.\n    return dict(key_db.setdefault(\"keys\"))\n\n\ndef get_key_count(keys, command_line_key):\n    \"\"\"\n    This function takes in two arguments: a list of keys and a command line key. It returns the number of times the keys appear in the command line key.\n\n    :param keys: A list of keys to search for in the command line key.\n    :type keys: list\n    :param command_line_key: The command line key to search for the keys in.\n    :type command_line_key: str\n    :return: The number of times the keys appear in the command line key.\n    :rtype: int\n    \"\"\"\n    # The length of the list of keys that appear in the command line key is returned.\n    return len([key for key in keys if key in command_line_key])\n\n\ndef add_keys_to_remote(c, command_line_keys, all_key_information):\n    \"\"\"\n    Adds SSH keys to a remote server's authorized keys file.\n\n    :param c: An object representing a connection to the remote server.\n    :type c: Connection\n    :param command_line_keys: A list of keys to be added to the remote server.\n    :type command_line_keys: list\n    :param all_key_information: A dictionary containing information about all available keys.\n    :type all_key_information: dict\n    \"\"\"\n    # If the user enters a key that isn't in the YAML file, it will break out of the loop.\n    for command_line_key in command_line_keys:\n        if command_line_key not in all_key_information:\n            break\n\n        all_key_information_remote_items = dict(\n            all_key_information[command_line_key].items()\n        )\n\n        keys = [\n            name\n            for name in [\"key\", \"datetime\", \"who@hostname\", \"message\"]\n            if name in all_key_information_remote_items\n        ]\n\n        # 4 as in the 4 items in the dictionary above (key, datetime, who@hostname, message)\n        if len(keys) == 4:\n            # It puts the keys in the authorized_keys file on the remote server.\n            # So the public key is now on the remote server.\n            # This means that the user can now log in to the remote server using the private key.\n            c.run(\n                f'echo \"{all_key_information_remote_items[\"key\"]}\" >> ~/.ssh/authorized_keys'\n            )\n            # This is a way to check if the key is already in the authorized_keys file.\n            # By making another file with all the keys and call the function 'sort -u' on it.\n            # This function sorts the keys and removes duplicates.\n            c.run(\"touch ~/.ssh/keys\")\n            c.run(\"sort -u ~/.ssh/authorized_keys > ~/.ssh/keys\")\n            time.sleep(1)\n            c.run(\"cp ~/.ssh/keys ~/.ssh/authorized_keys\")\n            c.run(\"rm ~/.ssh/keys\")\n            print(\n                f\"It worked out! The \\033[1m{command_line_key}\\033[0m key is added to the remote server.\"\n            )\n\n\ndef remote_key_doesnt_exist(c, command_line_keys, all_key_information):\n    \"\"\"\n    This function checks if the keys provided in the command line are present in the YAML file.\n    If a key is not present in the YAML file, the user is prompted to create it.\n\n    :param c: Connection object\n    :param command_line_keys: List of keys provided in the command line\n    :param all_key_information: Dictionary containing all key information from the YAML file\n    \"\"\"\n    # removing all keys that are already in the yaml file, so we can create the ones that are not in the yaml file\n    # and then add them to the yaml file\n    not_in_yaml_keys = [\n        which_key\n        for which_key in command_line_keys\n        if which_key not in all_key_information.keys()\n    ]\n    print(\n        f'Wrong \\033[1m{\" \".join(not_in_yaml_keys)}\\033[0m key, '\n        f\"first check if you filled in the right key. Or if it is in the YAML file.\"\n    )\n    # Here is the '-' replaced with a space, so it can be used in the generate function.\n    # The generate function requires two out of three arguments to be filled in. So that's why the key is split.\n    for which_key in not_in_yaml_keys:\n        if \"-\" not in which_key:\n            print(f\"\\033[1m{which_key}\\033[0m isn't a valid host-name please give it up with the format: owner-hostname-goal\")\n            continue\n\n        new_key = which_key.replace(\"-\", \" \")\n\n        # Create the key that isn't in the YAML file.\n        if input(f\"Do you want to create {which_key}? [Y/n]: \").replace(\" \", \"\") in (\n            \"y\",\n            \"Y\",\n            \"\",\n        ):\n            generate_message = str(\n                input(\"What message do you want to go with the ssh-key? REQUIRED: \")\n            )\n            if not generate_message:\n                print(\"Please give up a message for the next time!\")\n                exit(1)\n            key_split = new_key.split()\n\n            if len(key_split) > 3:\n                print(f\"to many arguments given in the key: {which_key} format needs to be: owner-hostname-goal\")\n\n            # This is to create a new key, the split is to make sure that the key is in the right format.\n            generate(\n                c,\n                generate_message,\n                owner=key_split[0],\n                hostname=key_split[1],\n                goal=new_key.split()[2] if len(key_split) == 3 else \"\",\n            )\n            # eventually it will add the keys that are just created\n            add_to_remote(c, command_line_keys)\n\n\n@task(\n    help={\n        \"keys-to-remote\": \"list of keys you want to add to the remote server\",\n    },\n    iterable=[\"keys_to_remote\"],\n)\ndef add_to_remote(c, keys_to_remote: list):\n    \"\"\"\n    Adds the specified SSH key(s) to the remote machine. You can add multiple keys at once.\n\n    The private/public key is located local in the ~/.managed_ssh_keys-{key_name} directory.\n    You can see who has the private/public key, by looking at the YAML file.\n    There is a key called 'who@hostname', that's the person who created the new ssh key.\n\n\n    If there are keys that are not in the YAML file, the user is prompted to create them.\n    NOTE: you must provide a message, otherwise the program will terminate.\n    \"\"\"\n    # If keys_to_remote is a string, convert it to a list with a single element\n    if type(keys_to_remote) == str:\n        keys_to_remote = [keys_to_remote]\n\n    # check which keys are already in the YAML file\n    all_key_information = dict(get_keys_from_keyholder())\n\n    # check if given keys exist else ask to generate them\n    key_count = get_key_count(all_key_information.keys(), keys_to_remote)\n\n    if key_count == len(keys_to_remote):\n        add_keys_to_remote(c, keys_to_remote, all_key_information)\n    else:\n        remote_key_doesnt_exist(c, keys_to_remote, all_key_information)\n\n\n@task(\n    help={\n        \"keys_to_remote\": \"list of keys you want to remove from the server\",\n    },\n    iterable=[\"keys_to_remote\"],\n)\ndef delete_remote(c, keys_to_remote):\n    \"\"\"\n    Removes the specified SSH key(s) from the remote machine. You can remove multiple keys at once.\n    \"\"\"\n    # If keys_to_remote is a string, convert it to a list with a single element\n    if type(keys_to_remote) == str:\n        keys_to_remote = [keys_to_remote]\n\n    # Get all key information from the keyholder\n    all_key_information = get_keys_from_keyholder()\n\n    # Loop through each key specified in keys_to_remote\n    for command_line_key in keys_to_remote:\n        # If the key is not found in all_key_information, break out of the loop\n        if command_line_key not in all_key_information:\n            break\n\n        # Get the SSH key from all_key_information and remove newlines\n        ssh_key = dict(all_key_information[command_line_key].items())[\"key\"].replace(\n            \"\\n\", \"\"\n        )\n        # Remove the key from the remote server's authorized_keys file\n        c.run(f'grep -v \"{ssh_key}\" ~/.ssh/authorized_keys > ~/.ssh/keys')\n        c.run(\"mv ~/.ssh/keys ~/.ssh/authorized_keys\")\n        # Print a success message\n        print(f\"Success! The {command_line_key} key has been removed.\")\n\n\n@task(\n    help={\n        \"message\": \"a message to know what the key is used for, REQUIRED\",\n        \"owner\": \"owner of the server you are generating a key for\",\n        \"hostname\": \"hostname of the server you are generating the key for\",\n        \"goal\": \"What is the goal to use this key for, for example: 'production' or 'testing''\",\n    }\n)\ndef generate(c, message, owner=\"\", hostname=\"\", goal=\"\"):\n    \"\"\"\n    This function generates a new SSH key and saves it to a yaml file. (~/.ssh/known_keys.yaml)\n\n    You need a message and 2 out of 3 arguments to generate a new key. (owner, hostname, goal) Otherwise it will fail.\n\n    The private/public key is located local in the ~/.managed_ssh_keys-{key_name} directory.\n    You can see who has the private/public key, by looking at the YAML file.\n    There is a key called 'who@hostname', that's the person who created the new ssh key.\n    \"\"\"\n    # Create a new YAML file if it does not already exist\n    create_new_yaml_file_if_not_exists()\n\n    # Create a key name by joining the non-empty values of owner, hostname, and goal with a hyphen\n    key_name = \"-\".join(filter(bool, [owner, hostname, goal]))\n    # If less than two of three from owner, hostname, and goal are provided, print an error message and return\n    if sum([owner != \"\", hostname != \"\", goal != \"\"]) < 2:\n        print(\n            \"Please provide at least two of the following arguments: Owner, Hostname, goal\"\n        )\n        return\n\n    # If a file with the specified key name already exists, print an error message and return\n    if pathlib.Path(f\"~/.managed_ssh_keys-{key_name}\").expanduser().exists():\n        print(f\"{key_name} already exists. Key generation aborted.\")\n        return\n\n    # Run the ssh-keygen command to generate a new SSH key\n    # As type of key we use rsa, with a bit size of 4096\n    # The key is saved in ~/.ssh/.managed_ssh_keys-{key_name}\n    # The key has no passphrase\n    # The key has given a comment with the message\n    subprocess.run(\n        f'ssh-keygen -t rsa -b 4096 -f ~/.ssh/.managed_ssh_keys-{key_name} -N \"\" -C \"{message}\"',\n        shell=True,\n    )\n\n    # Open the YAML_KEYS_PATH file in append mode\n    with open(YAML_KEYS_PATH, \"a\") as f:\n        # Dump the key information to the YAML file\n        yaml.dump(\n            {\n                \"keys\": {\n                    key_name: {\n                        \"key\": open(\n                            pathlib.Path(\n                                f\"~/.ssh/.managed_ssh_keys-{key_name}.pub\"\n                            ).expanduser()\n                        ).read(),\n                        \"datetime\": datetime.today().strftime(\n                            \"Datum: %Y-%m-%d Tijdstip: %H:%M:%S\"\n                        ),\n                        \"who@hostname\": f\"{os.getlogin()}@{platform.node()}\",\n                        \"message\": message,\n                    }\n                }\n            },\n            f,\n            indent=4,\n        )\n    # Print a success message\n    print(f\"Public key saved in ~/.managed_ssh_keys-{key_name}.pub\")\n    print(f\"Private key saved in ~/.managed_ssh_keys-{key_name}\")\n\n\n@task()\ndef list(c):\n    \"\"\"\n    Lists all the local or local and remote ssh_keys.\n    This function lists the authorized keys on a remote machine and compares them with the keys in a local YAML file.\n    It separates the keys into three categories: local keys, remote known keys, and unrecognized keys.\n    \"\"\"\n    # Load the keys from the YAML file\n    all_key_information = get_keys_from_keyholder()\n\n    # Get the list of authorized keys from the remote machine\n    if len(c.run(\"ls ~/.ssh/authorized_keys\", warn=True, hide=True).stdout) > 0:\n        remote_keys = c.run(\"cat ~/.ssh/authorized_keys\", hide=True).stdout\n    else:\n        remote_keys = \"\"\n\n    # Iterate through the keys and separate them into two lists\n    local_keys = []\n    remote_known_keys = []\n    for key_data in all_key_information.values():\n        if key_data[\"key\"] in remote_keys:\n            remote_known_keys.append(key_data[\"key\"].replace(\"\\n\", \"\"))\n        else:\n            local_keys.append(key_data[\"key\"])\n\n    remote_keys = remote_keys.split(\"\\n\")\n\n    # Check for any unrecognized keys in the authorized_keys file\n    if len(c.run(\"ls ~/.ssh/authorized_keys\", warn=True, hide=True).stdout) > 0:\n        unrecognized_keys = [\n            remote_key\n            for remote_key in remote_keys\n            if remote_key not in remote_known_keys and remote_key != \"\"\n        ]\n    else:\n        unrecognized_keys = [\n            remote_key for remote_key in remote_keys if remote_key != \"\"\n        ]\n\n    if unrecognized_keys:\n        print(\"\\033[1mUnrecognized keys found in remote auth_keys:\\033[0m\")\n        # If there are unrecognized keys, print them with a number, so you can see how many there are.\n        for index in range(len(unrecognized_keys)):\n            print(f\"key {index+1}\")\n            print(unrecognized_keys[index])\n            print()\n        print()\n\n    # Display the keys in a table\n    if local_keys or remote_known_keys:\n        if local_keys:\n            print(\"\\033[1mLocal Keys\\033[0m\")\n            for key in local_keys:\n                print(f\"\\033[33m{key}\\033[0m\")\n\n        if remote_known_keys:\n            print(\"\\033[1mRemote Keys\\033[0m\")\n            for key in remote_known_keys:\n                print(f\"\\033[33m{key}\\033[0m\")\n    else:\n        print(\"No keys found in key_holder.yaml\")\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/edwh_sshkey_plugin/fabfile.py b/src/edwh_sshkey_plugin/fabfile.py
--- a/src/edwh_sshkey_plugin/fabfile.py	(revision 94445e2968148e18eaddd14506e8eb1c0b7bd6e9)
+++ b/src/edwh_sshkey_plugin/fabfile.py	(date 1683905006298)
@@ -385,3 +385,6 @@
                 print(f"\033[33m{key}\033[0m")
     else:
         print("No keys found in key_holder.yaml")
+
+@task
+def test(c):
